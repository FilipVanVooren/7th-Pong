XAS99 CROSS-ASSEMBLER   VERSION 1.7.0
**** **** ****     > 7thpong_cart.asm
0001               ***************************************************************
0002               *
0003               *  _________  __  .__      __________
0004               *  \______  _/  |_|  |__   \______   \____   ____   ____
0005               *      /    \   __|  |  \   |     ___/  _ \ /    \ / ___\
0006               *     /    / |  | |   Y  \  |    |  (  <_> |   |  / /_/  >
0007               *    /____/  |__| |___|  /  |____|   \____/|___|  \___  /
0008               *                      \/                       \/_____/
0009               *
0010               *          7th Pong - Arcade Game Entry for the
0011               *         4K Short'n'Sweet game contest 2017-2018
0012               *
0013               *             (c)2017-2018 // Retroclouds Team
0014               *
0015               ***************************************************************
0016               * This file: 7thpong_cart.asm       ; Version 180330.1628
0017               *--------------------------------------------------------------
0018               * This is the cartridge version of "7th Pong".
0019               * Runs on an unexpanded console.
0020               ********@*****@*********************@**************************
0021                       save  >6000,>7fff
0022                       aorg  >6000
0023               *--------------------------------------------------------------
0024               *debug                 equ  1       ; Turn on debugging
0025               *--------------------------------------------------------------
0026               * Skip unused spectra2 code modules for reduced code size
0027               *--------------------------------------------------------------
0028      0001     use_osrom_constants    equ  1       ; Take constants from TI-99/4A OS ROM
0029      0001     skip_rom_bankswitch    equ  1       ; Skip ROM bankswitching support
0030      0001     skip_cpu_cpu_copy      equ  1       ; Skip CPU  to CPU copy functions
0031      0001     skip_vram_cpu_copy     equ  1       ; Skip VRAM to CPU copy functions
0032      0001     skip_grom_cpu_copy     equ  1       ; Skip GROM to CPU copy functions
0033      0001     skip_grom_vram_copy    equ  1       ; Skip GROM to VDP vram copy functions
0034      0001     skip_textmode_support  equ  1       ; Skip 40x24 textmode support
0035      0001     skip_f18a_support      equ  1       ; Skip f18a support
0036      0001     skip_vdp_boxes         equ  1       ; Skip filbox, putbox
0037      0001     skip_vdp_hexsupport    equ  1       ; Skip mkhex, puthex
0038      0001     skip_vdp_bitmap        equ  1       ; Skip bitmap functions
0039      0001     skip_vdp_intscr        equ  1       ; Skip interrupt+screen on/off
0040      0001     skip_vdp_viewport      equ  1       ; Skip viewport functions
0041      0001     skip_vdp_yx2px_calc    equ  1       ; Skip YX to pixel calculation
0042      0001     skip_tms52xx_detection equ  1       ; Skip speech synthesizer detection
0043      0001     skip_keyboard_real     equ  1       ; Skip real keyboard support
0044      0001     skip_random_generator  equ  1       ; Skip random functions
0045               *--------------------------------------------------------------
0046               * Cartridge header
0047               *--------------------------------------------------------------
0048 6000 AA01     grmhdr  byte  >aa,1,1,0,0,0
     6002 0100 
     6004 0000 
0049 6006 6010             data  prog0
0050 6008 0000             byte  0,0,0,0,0,0,0,0
     600A 0000 
     600C 0000 
     600E 0000 
0051 6010 0000     prog0   data  0                     ; No more items following
0052 6012 6774             data  cold_boot
0057 6014 0937             byte 9
0058 6015 ....             text '7TH PONG'
0060               *--------------------------------------------------------------
0061               * Include required files
0062               *--------------------------------------------------------------
0063                       copy  "runlib.asm"
**** **** ****     > runlib.asm
0001               *******************************************************************************
0002               *              ___  ____  ____  ___  ____  ____    __    ___
0003               *             / __)(  _ \( ___)/ __)(_  _)(  _ \  /__\  (__ \
0004               *             \__ \ )___/ )__)( (__   )(   )   / /(__)\  / _/
0005               *             (___/(__)  (____)\___) (__) (_)\_)(__)(__)(____)
0006               *
0007               *                 TMS9900 Monitor & Arcade Game Library
0008               *                                for
0009               *                   the Texas Instruments TI-99/4A
0010               *
0011               *                    2010-2018 by Filip Van Vooren
0012               *
0013               *              https://github.com/FilipVanVooren/spectra2.git
0014               *******************************************************************************
0015               * Credits
0016               *     1) Speech code based on version of Mark Wills
0017               *     2) Number conversion based on work of Mathew Hagerty
0018               *     3) Bold font style based on work of sometimes99er
0019               *******************************************************************************
0020               * This file: runlib.a99
0021               *******************************************************************************
0022               * NOTE
0023               * 14-03-2018    bit 10 CONFIG register reserved for alpha lock key down!
0024               *               But code in VIRKB buggy and disabled for now
0025               * 25-03-2018    LDFNT routine is not using tmp3. Tighten registers useful?
0026               *******************************************************************************
0027               * v1.2    2018/03   Work-in-Progress
0028               *         Bug-fix   Virtual keyboard was missing keys for player 2. Resolved
0029               *                   by adding "O" (p2 up), "," (p2 down), "K" (p2 left) and
0030               *                   "L" (p2 right)
0031               *         Change    Refactored GROM memory code into modules.
0032               *                   Removed dependency of GROM module in LDFNT routine.
0033               *                   Refactored library startup code to reduce code dependencies.
0034               *         Bug-fix   Fixed bug in Speech Synthesizer detection (spconn)
0035               *         Change    Reworked speech player routine (spplay).
0036               *                   Removed resident speech check. Only support speek external
0037               *                   Removed parameter P1 in (spprep) routine.
0038               *         New       Use constants embedded in OS ROM for reduced code size and
0039               *                   faster (16 bit) memory access.
0040               *         New       Introduced equates for skipping subroutines, allowing
0041               *                   you to reduce code size.
0042               *         Change    Repurpose bit 12 in CONFIG register from "keyboard mode" to
0043               *                   "VDP9918 sprite collision" detected.
0044               *                   This is a crucial change.
0045               *                   Bit 12 in CONFIG is set if C bit in VDP status register is
0046               *                   on. The important thing is that bit 12 is latched even
0047               *                   if C bit in VDP status register is reset (due to reading
0048               *                   VDP status register). You need to clear bit 12 manually
0049               *                   in your sprite collision routine.
0050               *         Change    Removed TI-99/4 check upon initialisation for saving
0051               *                   on code size/GROM support..
0052               *         New       Start breaking the monolith, use modules that can
0053               *                   be included when needed only. Major refactoring
0054               *         New       Added CLHOOK broutine
0055               *         Bug-fix   Fixed low-level VDP routines because of wrong VDP bits set.
0056               *         Change    Removed use of config bit 1 in MKHEX subroutine and
0057               *                   got rid of multiple colors possibility.
0058               *         Change    Removed OS v2.2 check (config bit 10) and repurpose bit 5.
0059               *                   Check if speech synthesizer present upon startup.
0060               *         New       Check if F18A present upon startup (config bit 1)
0061               *         Change    Repurpose bit 1 in CONFIG register from "subroutine state
0062               *                   flag 1" to "F18A present flag"
0063               *         Change    Converted source from upper case to lower case
0064               *         New       F18A support routines (detect, 80 cols, ...)
0065               *         Bug-fix   Removed 6 years-old bug!
0066               *                   Overflow in calculation of X in YX2PNT routine
0067               *                   resulted in wrong VDP target address.
0068               *------------------------------------------------------------------------------
0069               * v1.1    2011/05   This version was never officially released
0070               *                   but contains many changes and some new functions.
0071               *         Bug-fix   by TREV2005. Fixed YX2PYX register issue
0072               *         Change    Introduced memory location @WCOLMN and rewrote YX2PNT
0073               *                   for using MPY instruction.
0074               *                   Adjusted format of video mode table to include number
0075               *                   of columns per row.
0076               *                   VIDTAB subroutine adjusted as well.
0077               *         Change    Removed subroutine GTCLMN. The functionality is replaced
0078               *                   by the @WCOLMN memory location.
0079               *         New       Added subroutine SCRDIM for setting base and
0080               *                   width of a virtual screen.
0081               *         Change    Introduced memory locations WAUX1,WAUX2,WAUX3.
0082               *         Change    PUTBOX completely rewritten, now supports repeating
0083               *                   vertically and/or horizontally.
0084               *                   This is how its supposed to work from day one..
0085               *                   WARNING PUTBOX is not compatible with V1.
0086               *                   width & height swapped in P1.
0087               *         Change    Removed memory location WSEED.
0088               *                   On startup value is in WAUX1.
0089               *                   Added parameter P1 to RND subroutine (address random seed)
0090               *         Change    Modified FILBOX subroutine. Width and height swapped
0091               *                   in P1 so that it's the same as for PUTBOX subroutine.
0092               *         New       Added VIEW subroutine. This is a viewport into
0093               *                   a virtual screen.
0094               *         New       Added RLE2V subroutine.
0095               *                   Decompress RLE (Run Length Encoded data) to VRAM.
0096               *------------------------------------------------------------------------------
0097               * v1.0    2011/02   Initial version
0098               *******************************************************************************
0099               * Use following equates to skip/exclude support modules
0100               *
0101               * skip_rom_bankswitch       equ  1       ; Skip support for ROM bankswitching
0102               * skip_vram_cpu_copy        equ  1       ; Skip VRAM to CPU copy functions
0103               * skip_cpu_vram_copy        equ  1       ; Skip CPU  to VRAM copy functions
0104               * skip_cpu_cpu_copy         equ  1       ; Skip CPU  to CPU copy functions
0105               * skip_grom_cpu_copy        equ  1       ; Skip GROM to CPU copy functions
0106               * skip_grom_vram_copy       equ  1       ; Skip GROM to VRAM copy functions
0107               * skip_textmode_support     equ  1       ; Skip 40x24 textmode support
0108               * skip_f18a_support         equ  1       ; Skip f18a support
0109               * skip_vdp_hchar            equ  1       ; Skip hchar, xchar
0110               * skip_vdp_vchar            equ  1       ; Skip vchar, xvchar
0111               * skip_vdp_boxes            equ  1       ; Skip filbox, putbox
0112               * skip_vdp_hexsupport       equ  1       ; Skip mkhex, puthex
0113               * skip_vdp_bitmap           equ  1       ; Skip bitmap functions
0114               * skip_vdp_intscr           equ  1       ; Skip interrupt+screen on/off
0115               * skip_vdp_viewport         equ  1       ; Skip viewport functions
0116               * skip_vdp_rle_decompress   equ  1       ; Skip RLE decompress to VRAM
0117               * skip_vdp_yx2px_calc       equ  1       ; Skip YX to pixel calculation
0118               * skip_vdp_px2yx_calc       equ  1       ; Skip pixel to YX calculation
0119               * skip_tms52xx_detection    equ  1       ; Skip speech synthesizer detection
0120               * skip_keyboard_real        equ  1       ; Skip real keyboard support
0121               * skip_random_generator     equ  1       ; Skip random functions
0122               * use_osrom_constants       equ  1       ; Take constants from TI-99/4A OS ROM
0123               *******************************************************************************
0124               
0125               
0126               
0127               *//////////////////////////////////////////////////////////////
0128               *                       RUNLIB MEMORY SETUP
0129               *//////////////////////////////////////////////////////////////
0130               
0131               ***************************************************************
0132               * >8300 - >8341     Scratchpad memory layout (66 bytes)
0133               ********@*****@*********************@**************************
0134      8300     ws1     equ   >8300                 ; 32 - Primary workspace
0135      8320     mcloop  equ   >8320                 ; 08 - Machine code for loop & speech
0136      8328     wbase   equ   >8328                 ; 02 - PNT base address
0137      832A     wyx     equ   >832a                 ; 02 - Cursor YX position
0138      832C     wtitab  equ   >832c                 ; 02 - Timers: Address of timer table
0139      832E     wtiusr  equ   >832e                 ; 02 - Timers: Address of user hook
0140      8330     wtitmp  equ   >8330                 ; 02 - Timers: Internal use
0141      8332     wvrtkb  equ   >8332                 ; 02 - Virtual keyboard flags
0142      8334     wsdlst  equ   >8334                 ; 02 - Sound player: Tune address
0143      8336     wsdtmp  equ   >8336                 ; 02 - Sound player: Temporary use
0144      8338     wspeak  equ   >8338                 ; 02 - Speech player: Address of LPC data
0145      833A     wcolmn  equ   >833a                 ; 02 - Screen size, columns per row
0146      833C     waux1   equ   >833c                 ; 02 - Temporary storage 1
0147      833E     waux2   equ   >833e                 ; 02 - Temporary storage 2
0148      8340     waux3   equ   >8340                 ; 02 - Temporary storage 3
0149               ***************************************************************
0150      832A     by      equ   wyx                   ;      Cursor Y position
0151      832B     bx      equ   wyx+1                 ;      Cursor X position
0152      8322     mcsprd  equ   mcloop+2              ;      Speech read routine
0153               ***************************************************************
0154               * Register usage
0155               * R0-R3   General purpose registers
0156               * R4-R8   Temporary registers
0157               * R9      Stack pointer
0158               * R10     Highest slot in use + Timer counter
0159               * R11     Subroutine return address
0160               * R12     Configuration register
0161               * R13     Copy of VDP status byte and counter for sound player
0162               * R14     Copy of VDP register #0 and VDP register #1 bytes
0163               * R15     VDP read/write address
0164               ***************************************************************
0165               * Workspace and register equates
0166               ********@*****@*********************@**************************
0167      0000     r0      equ   0
0168      0001     r1      equ   1
0169      0002     r2      equ   2
0170      0003     r3      equ   3
0171      0004     r4      equ   4
0172      0005     r5      equ   5
0173      0006     r6      equ   6
0174      0007     r7      equ   7
0175      0008     r8      equ   8
0176      0009     r9      equ   9
0177      000A     r10     equ   10
0178      000B     r11     equ   11
0179      000C     r12     equ   12
0180      000D     r13     equ   13
0181      000E     r14     equ   14
0182      000F     r15     equ   15
0183      8300     r0hb    equ   ws1                   ; HI byte R0
0184      8301     r0lb    equ   ws1+1                 ; LO byte R0
0185      8302     r1hb    equ   ws1+2                 ; HI byte R1
0186      8303     r1lb    equ   ws1+3                 ; LO byte R1
0187      8304     r2hb    equ   ws1+4                 ; HI byte R2
0188      8305     r2lb    equ   ws1+5                 ; LO byte R2
0189      8306     r3hb    equ   ws1+6                 ; HI byte R3
0190      8307     r3lb    equ   ws1+7                 ; LO byte R3
0191      8308     r4hb    equ   ws1+8                 ; HI byte R4
0192      8309     r4lb    equ   ws1+9                 ; LO byte R4
0193      830A     r5hb    equ   ws1+10                ; HI byte R5
0194      830B     r5lb    equ   ws1+11                ; LO byte R5
0195      830C     r6hb    equ   ws1+12                ; HI byte R6
0196      830D     r6lb    equ   ws1+13                ; LO byte R6
0197      830E     r7hb    equ   ws1+14                ; HI byte R7
0198      830F     r7lb    equ   ws1+15                ; LO byte R7
0199      8310     r8hb    equ   ws1+16                ; HI byte R8
0200      8311     r8lb    equ   ws1+17                ; LO byte R8
0201      8312     r9hb    equ   ws1+18                ; HI byte R9
0202      8313     r9lb    equ   ws1+19                ; LO byte R9
0203      8314     r10hb   equ   ws1+20                ; HI byte R10
0204      8315     r10lb   equ   ws1+21                ; LO byte R10
0205      8316     r11hb   equ   ws1+22                ; HI byte R11
0206      8317     r11lb   equ   ws1+23                ; LO byte R11
0207      8318     r12hb   equ   ws1+24                ; HI byte R12
0208      8319     r12lb   equ   ws1+25                ; LO byte R12
0209      831A     r13hb   equ   ws1+26                ; HI byte R13
0210      831B     r13lb   equ   ws1+27                ; LO byte R13
0211      831C     r14hb   equ   ws1+28                ; HI byte R14
0212      831D     r14lb   equ   ws1+29                ; LO byte R14
0213      831E     r15hb   equ   ws1+30                ; HI byte R15
0214      831F     r15lb   equ   ws1+31                ; LO byte R15
0215      0004     tmp0    equ   r4                    ; Temp register 0
0216      0005     tmp1    equ   r5                    ; Temp register 1
0217      0006     tmp2    equ   r6                    ; Temp register 2
0218      0007     tmp3    equ   r7                    ; Temp register 3
0219      0008     tmp4    equ   r8                    ; Temp register 4
0220      0009     tmp5    equ   r9                    ; Temp register 5
0221      000F     tmp6    equ   r15                   ; Temp register 6
0222      8308     tmp0hb  equ   ws1+8                 ; HI byte R4
0223      8309     tmp0lb  equ   ws1+9                 ; LO byte R4
0224      830A     tmp1hb  equ   ws1+10                ; HI byte R5
0225      830B     tmp1lb  equ   ws1+11                ; LO byte R5
0226      830C     tmp2hb  equ   ws1+12                ; HI byte R6
0227      830D     tmp2lb  equ   ws1+13                ; LO byte R6
0228      830E     tmp3hb  equ   ws1+14                ; HI byte R7
0229      830F     tmp3lb  equ   ws1+15                ; LO byte R7
0230      8310     tmp4hb  equ   ws1+16                ; HI byte R8
0231      8311     tmp4lb  equ   ws1+17                ; LO byte R8
0232      8310     tmp5hb  equ   ws1+16                ; HI byte R8
0233      8311     tmp5lb  equ   ws1+17                ; LO byte R8
0234      831E     tmp6hb  equ   ws1+30                ; HI byte R15
0235      831F     tmp6lb  equ   ws1+31                ; LO byte R15
0236               ***************************************************************
0237               * Equates for VDP, GROM, SOUND, SPEECH ports
0238               ********@*****@*********************@**************************
0239      8400     sound   equ   >8400                 ; Sound generator address
0240      8800     vdpr    equ   >8800                 ; VDP read data window address
0241      8C00     vdpw    equ   >8c00                 ; VDP write data window address
0242      8802     vdps    equ   >8802                 ; VDP status register
0243      8C02     vdpa    equ   >8c02                 ; VDP address register
0244      9C02     grmwa   equ   >9c02                 ; GROM set write address
0245      9802     grmra   equ   >9802                 ; GROM set read address
0246      9800     grmrd   equ   >9800                 ; GROM read byte
0247      9C00     grmwd   equ   >9c00                 ; GROM write byte
0248      9000     spchrd  equ   >9000                 ; Address of speech synth Read Data Register
0249      9400     spchwt  equ   >9400                 ; Address of speech synth Write Data Register
0250               ***************************************************************
0251               * Equates for registers
0252               ********@*****@*********************@**************************
0253      0009     stack   equ   r9                    ; Stack pointer
0254      8314     btihi   equ   ws1+20                ; Highest slot in use (HI byte R10)
0255      000C     config  equ   r12                   ; SPECTRA configuration register
0256      831A     bvdpst  equ   ws1+26                ; Copy of VDP status register (HI byte R13)
0257      000E     vdpr01  equ   r14                   ; Copy of VDP#0 and VDP#1 bytes
0258      831C     vdpr0   equ   ws1+28                ; High byte of R14. Is VDP#0 byte
0259      831D     vdpr1   equ   ws1+29                ; Low byte  of R14. Is VDP#1 byte
0260      000F     vdprw   equ   r15                   ; Contains VDP read/write address
0261               ***************************************************************
0262               * Equates for memory locations
0263               ********@*****@*********************@**************************
0264      832E     wramf   equ   >832e                 ; Memory location F
0265      8338     wramk   equ   >8338                 ; Memory location K
0266      833A     wraml   equ   >833a                 ; Memory location L
0267               ***************************************************************
0268               * The config register equates
0269               *--------------------------------------------------------------
0270               * Configuration flags
0271               * ===================
0272               *
0273               * ; 15  Sound player: tune source       1=ROM/RAM      0=VDP MEMORY
0274               * ; 14  Sound player: repeat tune       1=yes          0=no
0275               * ; 13  Sound player: enabled           1=yes          0=no (or pause)
0276               * ; 12  VDP9918 sprite collision?       1=yes          0=no
0277               * ; 11  Keyboard: ANY key pressed       1=yes          0=no
0278               * ; 10  Keyboard: Alpha lock key down   1=yes          0=no
0279               * ; 09  Timer: Kernel thread enabled    1=yes          0=no
0280               * ; 08  Timer: Block kernel thread      1=yes          0=no
0281               * ; 07  Timer: User hook enabled        1=yes          0=no
0282               * ; 06  Timer: Block user hook          1=yes          0=no
0283               * ; 05  Speech synthesizer present      1=yes          0=no
0284               * ; 04  Speech player: busy             1=yes          0=no
0285               * ; 03  Speech player: enabled          1=yes          0=no
0286               * ; 02  VDP9918 PAL version             1=yes(50)      0=no(60)
0287               * ; 01  F18A present                    1=on           0=off
0288               * ; 00  Subroutine state flag           1=on           0=off
0289               ********@*****@*********************@**************************
0290      2000     palon   equ   >2000                 ; bit 2=1   (VDP9918 PAL version)
0291      0100     enusr   equ   >0100                 ; bit 7=1   (Enable user hook)
0292      0040     enknl   equ   >0040                 ; bit 9=1   (Enable kernel thread)
0293      0020     tms5200 equ   >0020                 ; bit 10=1  (Speech Synthesizer present)
0294               ***************************************************************
0295               * Subroutine parameter equates
0296               ***************************************************************
0297      FFFF     eol     equ   >ffff                 ; End-Of-List
0298      FFFF     nofont  equ   >ffff                 ; Skip loading font in RUNLIB
0299      0000     norep   equ   0                     ; PUTBOX > Value for P3. Don't repeat box
0300      3030     num1    equ   >3030                 ; MKNUM  > ASCII 0-9, leading 0's
0301      3020     num2    equ   >3020                 ; MKNUM  > ASCII 0-9, leading spaces
0302      0007     sdopt1  equ   7                     ; SDPLAY > 111 (Player on, repeat, tune in CPU memory)
0303      0005     sdopt2  equ   5                     ; SDPLAY > 101 (Player on, no repeat, tune in CPU memory)
0304      0006     sdopt3  equ   6                     ; SDPLAY > 110 (Player on, repeat, tune in VRAM)
0305      0004     sdopt4  equ   4                     ; SDPLAY > 100 (Player on, no repeat, tune in VRAM)
0306      0000     fnopt1  equ   >0000                 ; LDFNT  > Load TI title screen font
0307      0006     fnopt2  equ   >0006                 ; LDFNT  > Load upper case font
0308      000C     fnopt3  equ   >000c                 ; LDFNT  > Load upper/lower case font
0309      0012     fnopt4  equ   >0012                 ; LDFNT  > Load lower case font
0310      8000     fnopt5  equ   >8000                 ; LDFNT  > Load TI title screen font  & bold
0311      8006     fnopt6  equ   >8006                 ; LDFNT  > Load upper case font       & bold
0312      800C     fnopt7  equ   >800c                 ; LDFNT  > Load upper/lower case font & bold
0313      8012     fnopt8  equ   >8012                 ; LDFNT  > Load lower case font       & bold
0314               *--------------------------------------------------------------
0315               *   Speech player
0316               *--------------------------------------------------------------
0317      0060     talkon  equ   >60                   ; 'start talking' command code for speech synth
0318      00FF     talkof  equ   >ff                   ; 'stop talking' command code for speech synth
0319      6000     spkon   equ   >6000                 ; 'start talking' command code for speech synth
0320      FF00     spkoff  equ   >ff00                 ; 'stop talking' command code for speech synth
0321               ***************************************************************
0322               * Virtual keyboard equates
0323               ***************************************************************
0324               * bit  0: ALPHA LOCK down             0=no  1=yes
0325               * bit  1: ENTER                       0=no  1=yes
0326               * bit  2: REDO                        0=no  1=yes
0327               * bit  3: BACK                        0=no  1=yes
0328               * bit  4: Pause                       0=no  1=yes
0329               * bit  5: *free*                      0=no  1=yes
0330               * bit  6: P1 Left                     0=no  1=yes
0331               * bit  7: P1 Right                    0=no  1=yes
0332               * bit  8: P1 Up                       0=no  1=yes
0333               * bit  9: P1 Down                     0=no  1=yes
0334               * bit 10: P1 Space / fire / Q         0=no  1=yes
0335               * bit 11: P2 Left                     0=no  1=yes
0336               * bit 12: P2 Right                    0=no  1=yes
0337               * bit 13: P2 Up                       0=no  1=yes
0338               * bit 14: P2 Down                     0=no  1=yes
0339               * bit 15: P2 Space / fire / Q         0=no  1=yes
0340               ***************************************************************
0341      8000     kalpha  equ   >8000                 ; Virtual key alpha lock
0342      4000     kenter  equ   >4000                 ; Virtual key enter
0343      2000     kredo   equ   >2000                 ; Virtual key REDO
0344      1000     kback   equ   >1000                 ; Virtual key BACK
0345      0800     kpause  equ   >0800                 ; Virtual key pause
0346      0400     kfree   equ   >0400                 ; ***NOT USED YET***
0347               *--------------------------------------------------------------
0348               * Keyboard Player 1
0349               *--------------------------------------------------------------
0350      0280     k1uplf  equ   >0280                 ; Virtual key up   + left
0351      0180     k1uprg  equ   >0180                 ; Virtual key up   + right
0352      0240     k1dnlf  equ   >0240                 ; Virtual key down + left
0353      0140     k1dnrg  equ   >0140                 ; Virtual key down + right
0354      0200     k1lf    equ   >0200                 ; Virtual key left
0355      0100     k1rg    equ   >0100                 ; Virtual key right
0356      0080     k1up    equ   >0080                 ; Virtual key up
0357      0040     k1dn    equ   >0040                 ; Virtual key down
0358      0020     k1fire  equ   >0020                 ; Virtual key fire
0359               *--------------------------------------------------------------
0360               * Keyboard Player 2
0361               *--------------------------------------------------------------
0362      0014     k2uplf  equ   >0014                 ; Virtual key up   + left
0363      000C     k2uprg  equ   >000c                 ; Virtual key up   + right
0364      0012     k2dnlf  equ   >0012                 ; Virtual key down + left
0365      000A     k2dnrg  equ   >000a                 ; Virtual key down + right
0366      0010     k2lf    equ   >0010                 ; Virtual key left
0367      0008     k2rg    equ   >0008                 ; Virtual key right
0368      0004     k2up    equ   >0004                 ; Virtual key up
0369      0002     k2dn    equ   >0002                 ; Virtual key down
0370      0001     k2fire  equ   >0001                 ; Virtual key fire
0371                       even
0372               
0373               
0374               ***************************************************************
0375               * Bank switch routine
0376               ***************************************************************
0380               
0381               
0382               ***************************************************************
0383               *                      Some constants
0384               ********@*****@*********************@**************************
0386      06A6     wbit0   equ   >06a6                 ; data >8000  Binary 1000000000000000
0387      023C     wbit1   equ   >023c                 ; data >4000  Binary 0100000000000000
0388 601E 2000     wbit2   data  >2000                 ; data >2000  Binary 0010000000000000
0389      0036     wbit3   equ   >0036                 ; data >1000  Binary 0001000000000000
0390      08C6     wbit4   equ   >08c6                 ; data >0800  Binary 0000100000000000
0391      0694     wbit5   equ   >0694                 ; data >0400  Binary 0000010000000000
0392      0030     wbit6   equ   >0030                 ; data >0200  Binary 0000001000000000
0393      002A     wbit7   equ   >002a                 ; data >0100  Binary 0000000100000000
0394      06B0     wbit8   equ   >06b0                 ; data >0080  Binary 0000000010000000
0395      101E     wbit9   equ   >101e                 ; data >0040  Binary 0000000001000000
0396      0032     wbit10  equ   >0032                 ; data >0020  Binary 0000000000100000
0397 6020 0010     wbit11  data  >0010                 ; data >0010  Binary 0000000000010000
0398      0012     wbit12  equ   >0012                 ; data >0008  Binary 0000000000001000
0399 6022 0004     wbit13  data  >0004                 ; data >0004  Binary 0000000000000100
0400 6024 0002     wbit14  data  >0002                 ; data >0002  Binary 0000000000000010
0401      0378     wbit15  equ   >0378                 ; data >0001  Binary 0000000000000001
0402      0E2C     whffff  equ   >0e2c                 ; data >ffff  Binary 1111111111111111
0403      0002     bd0     equ   >0002                 ; byte  0     Digit 0
0404      002A     bd1     equ   >002a                 ; byte  1     Digit 1
0405      002C     bd2     equ   >002c                 ; byte  2     Digit 2
0406      003E     bd3     equ   >003e                 ; byte  3     Digit 3
0407      000E     bd4     equ   >000e                 ; byte  4     Digit 4
0408      007B     bd5     equ   >007b                 ; byte  5     Digit 5
0409      004E     bd6     equ   >004e                 ; byte  6     Digit 6
0410      0090     bd7     equ   >0090                 ; byte  7     Digit 7
0411      0013     bd8     equ   >0013                 ; byte  8     Digit 8
0412      0006     bd9     equ   >0006                 ; byte  9     Digit 9
0413      00A6     bd208   equ   >00a6                 ; byte  208   Digit 208 (>D0)
0445               *--------------------------------------------------------------
0446               * Equates for constants
0447               *--------------------------------------------------------------
0448      6020     anykey  equ   wbit11                ; BIT 11 in the CONFIG register
0449      06A6     bbit0   equ   wbit0
0450      023C     bbit1   equ   wbit1
0451      601E     bbit2   equ   wbit2
0452      0036     bbit3   equ   wbit3
0453      08C6     bbit4   equ   wbit4
0454      0694     bbit5   equ   wbit5
0455      0030     bbit6   equ   wbit6
0456      002A     bbit7   equ   wbit7
0457      6021     bh10    equ   wbit11+1              ; >10
0458      0033     bh20    equ   wbit10+1              ; >20
0459      101F     bh40    equ   wbit9+1               ; >40
0460      06B1     bh80    equ   wbit8+1               ; >80
0461      0378     wd1     equ   wbit15                ; >0001
0462      0032     wh20    equ   wbit10                ; >0020
0463      101E     wh40    equ   wbit9                 ; >0040
0464      06B0     wh80    equ   wbit8                 ; >0080
0465      002A     wh100   equ   wbit7                 ; >0100
0466      023C     wh4000  equ   wbit1                 ; >4000
0467               
0468               
0469               ***************************************************************
0470               *                Data used by runtime library
0471               ********@*****@*********************@**************************
0472                       copy  "vdp_tables.asm"
**** **** ****     > vdp_tables.asm
0001               * FILE......: vdp_tables.a99
0002               * Purpose...: Video mode tables
0003               
0004               ***************************************************************
0005               * Graphics mode 1 (32 columns/24 rows)
0006               *--------------------------------------------------------------
0007 6026 00E2     graph1  byte  >00,>e2,>00,>0e,>01,>06,>02,SPFBCK,0,32
     6028 000E 
     602A 0106 
     602C 0201 
     602E 0020 
0008               * ; VDP#0 Control bits
0009               * ;      bit 6=0: M3 | Graphics 1 mode
0010               * ;      bit 7=0: Disable external VDP input
0011               * ; VDP#1 Control bits
0012               * ;      bit 0=1: 16K selection
0013               * ;      bit 1=1: Enable display
0014               * ;      bit 2=1: Enable VDP interrupt
0015               * ;      bit 3=0: M1 \ Graphics 1 mode
0016               * ;      bit 4=0: M2 /
0017               * ;      bit 5=0: reserved
0018               * ;      bit 6=1: 16x16 sprites
0019               * ;      bit 7=0: Sprite magnification (1x)
0020               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0021               * ; VDP#3 PCT (Pattern color table)      at >0380  (>0E * >040)
0022               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0023               * ; VDP#5 SAT (sprite attribute list)    at >0300  (>06 * >080)
0024               * ; VDP#6 SPT (Sprite pattern table)     at >1000  (>02 * >800)
0025               * ; VDP#7 Set screen background color
0026               
0027               
0053               
0054               
**** **** ****     > runlib.asm
0473               
0474               *--------------------------------------------------------------
0475               * ; Machine code for tight loop.
0476               * ; The MOV operation at MCLOOP must be injected by the calling routine.
0477               *--------------------------------------------------------------
0478               *       DATA  >????                 ; \ MCLOOP  MOV   ...
0479 6030 0606     mccode  data  >0606                 ; |         DEC   R6 (TMP2)
0480 6032 16FD             data  >16fd                 ; |         JNE   MCLOOP
0481 6034 045B             data  >045b                 ; /         B     *R11
0482               *--------------------------------------------------------------
0483               * ; Machine code for reading from the speech synthesizer
0484               * ; The SRC instruction takes 12 uS for execution in scratchpad RAM.
0485               * ; Is required for the 12 uS delay. It destroys R5.
0486               *--------------------------------------------------------------
0487 6036 D114     spcode  data  >d114                 ; \         MOVB  *R4,R4 (TMP0)
0488 6038 0BC5             data  >0bc5                 ; /         SRC   R5,12  (TMP1)
0489                       even
0490               
0491               
0492               *//////////////////////////////////////////////////////////////
0493               *                     FILL & COPY FUNCTIONS
0494               *//////////////////////////////////////////////////////////////
0495               
0496               
0497               ***************************************************************
0498               * FILM - Fill CPU memory with byte
0499               ***************************************************************
0500               *  BL   @FILM
0501               *  DATA P0,P1,P2
0502               *--------------------------------------------------------------
0503               *  P0 = Memory start address
0504               *  P1 = Byte to fill
0505               *  P2 = Number of bytes to fill
0506               *--------------------------------------------------------------
0507               *  BL   @XFILM
0508               *
0509               *  TMP0 = Memory start address
0510               *  TMP1 = Byte to fill
0511               *  TMP2 = Number of bytes to fill
0512               ********@*****@*********************@**************************
0513 603A C13B  30 film    mov   *r11+,tmp0            ; Memory start
0514 603C C17B  30         mov   *r11+,tmp1            ; Byte to fill
0515 603E C1BB  30         mov   *r11+,tmp2            ; Repeat count
0516               *--------------------------------------------------------------
0517               * Fill memory with 16 bit words
0518               *--------------------------------------------------------------
0519 6040 C1C6  18 xfilm   mov   tmp2,tmp3
0520 6042 0247  22         andi  tmp3,1                ; TMP3=1 -> ODD else EVEN
     6044 0001 
0521               
0522 6046 1301  14         jeq   film1
0523 6048 0606  14         dec   tmp2                  ; Make TMP2 even
0524 604A D820  54 film1   movb  @tmp1lb,@tmp1hb       ; Duplicate value
     604C 830B 
     604E 830A 
0525 6050 CD05  34 film2   mov   tmp1,*tmp0+
0526 6052 0646  14         dect  tmp2
0527 6054 16FD  14         jne   film2
0528               *--------------------------------------------------------------
0529               * Fill last byte if ODD
0530               *--------------------------------------------------------------
0531 6056 C1C7  18         mov   tmp3,tmp3
0532 6058 1301  14         jeq   filmz
0533 605A D505  30         movb  tmp1,*tmp0
0534 605C 045B  20 filmz   b     *r11
0535               
0536               
0537               ***************************************************************
0538               * FILV - Fill VRAM with byte
0539               ***************************************************************
0540               *  BL   @FILV
0541               *  DATA P0,P1,P2
0542               *--------------------------------------------------------------
0543               *  P0 = VDP start address
0544               *  P1 = Byte to fill
0545               *  P2 = Number of bytes to fill
0546               *--------------------------------------------------------------
0547               *  BL   @XFILV
0548               *
0549               *  TMP0 = VDP start address
0550               *  TMP1 = Byte to fill
0551               *  TMP2 = Number of bytes to fill
0552               ********@*****@*********************@**************************
0553 605E C13B  30 filv    mov   *r11+,tmp0            ; Memory start
0554 6060 C17B  30         mov   *r11+,tmp1            ; Byte to fill
0555 6062 C1BB  30         mov   *r11+,tmp2            ; Repeat count
0556               *--------------------------------------------------------------
0557               *    Setup VDP write address
0558               *--------------------------------------------------------------
0559 6064 0264  22 xfilv   ori   tmp0,>4000
     6066 4000 
0560 6068 06C4  14         swpb  tmp0
0561 606A D804  38         movb  tmp0,@vdpa
     606C 8C02 
0562 606E 06C4  14         swpb  tmp0
0563 6070 D804  38         movb  tmp0,@vdpa
     6072 8C02 
0564               *--------------------------------------------------------------
0565               *    Fill bytes in VDP memory
0566               *--------------------------------------------------------------
0567 6074 020F  20         li    r15,vdpw              ; Set VDP write address
     6076 8C00 
0568 6078 06C5  14         swpb  tmp1
0569 607A C820  54         mov   @filzz,@mcloop        ; Setup move command
     607C 1624 
     607E 8320 
0570 6080 0460  28         b     @mcloop               ; Write data to VDP
     6082 8320 
0571               *--------------------------------------------------------------
0573      1624     filzz   equ   >1624                 ; ^data >d7c5 (MOVB TMP1,*R15)
0577               
0578               
0579               *//////////////////////////////////////////////////////////////
0580               *                  CPU to VRAM copy functions
0581               *//////////////////////////////////////////////////////////////
0583                       copy  "cpu_vram_copy.asm"
**** **** ****     > cpu_vram_copy.asm
0001               * FILE......: cpu_vram_copy.asm
0002               * Purpose...: CPU memory to VRAM copy support module
0003               
0004               ***************************************************************
0005               * CPYM2V - Copy CPU memory to VRAM
0006               ***************************************************************
0007               *  BL   @CPYM2V
0008               *  DATA P0,P1,P2
0009               *--------------------------------------------------------------
0010               *  P0 = VDP start address
0011               *  P1 = RAM/ROM start address
0012               *  P2 = Number of bytes to copy
0013               *--------------------------------------------------------------
0014               *  BL @XPYM2V
0015               *
0016               *  TMP0 = VDP start address
0017               *  TMP1 = RAM/ROM start address
0018               *  TMP2 = Number of bytes to copy
0019               ********@*****@*********************@**************************
0020 6084 C13B  30 cpym2v  mov   *r11+,tmp0            ; VDP Start address
0021 6086 C17B  30         mov   *r11+,tmp1            ; RAM/ROM start address
0022 6088 C1BB  30         mov   *r11+,tmp2            ; Bytes to copy
0023               *--------------------------------------------------------------
0024               *    Setup VDP write address
0025               *--------------------------------------------------------------
0026 608A 0264  22 xpym2v  ori   tmp0,>4000
     608C 4000 
0027 608E 06C4  14         swpb  tmp0
0028 6090 D804  38         movb  tmp0,@vdpa
     6092 8C02 
0029 6094 06C4  14         swpb  tmp0
0030 6096 D804  38         movb  tmp0,@vdpa
     6098 8C02 
0031               *--------------------------------------------------------------
0032               *    Copy bytes from CPU memory to VRAM
0033               *--------------------------------------------------------------
0034 609A 020F  20         li    r15,vdpw              ; Set VDP write address
     609C 8C00 
0035 609E C820  54         mov   @tmp008,@mcloop       ; Setup copy command
     60A0 60A8 
     60A2 8320 
0036 60A4 0460  28         b     @mcloop               ; Write data to VDP
     60A6 8320 
0037 60A8 D7F5     tmp008  data  >d7f5                 ; MOVB *TMP1+,*R15
**** **** ****     > runlib.asm
0585               
0586               
0587               *//////////////////////////////////////////////////////////////
0588               *                  VRAM to CPU copy functions
0589               *//////////////////////////////////////////////////////////////
0593               
0594               
0595               *//////////////////////////////////////////////////////////////
0596               *                  CPU to CPU copy functions
0597               *//////////////////////////////////////////////////////////////
0601               
0602               
0603               *//////////////////////////////////////////////////////////////
0604               *                GROM to CPU copy functions
0605               *//////////////////////////////////////////////////////////////
0609               
0610               *//////////////////////////////////////////////////////////////
0611               *                GROM to VRAM copy functions
0612               *//////////////////////////////////////////////////////////////
0616               
0617               
0618               *//////////////////////////////////////////////////////////////
0619               *                  RLE decompress to VRAM
0620               *//////////////////////////////////////////////////////////////
0622                       copy  "vdp_rle_decompress.asm"
**** **** ****     > vdp_rle_decompress.asm
0001               * FILE......: vdp_rle_decompress.asm
0002               * Purpose...: RLE decompress to VRAM support module
0003               
0004               ***************************************************************
0005               * RLE2V - RLE decompress to VRAM memory
0006               ***************************************************************
0007               *  BL   @RLE2V
0008               *  DATA P0,P1,P2
0009               *--------------------------------------------------------------
0010               *  P0 = ROM/RAM source address
0011               *  P1 = VDP target address
0012               *  P2 = Length of RLE encoded data
0013               *--------------------------------------------------------------
0014               *  BL @RLE2VX
0015               *
0016               *  TMP0     = VDP target address
0017               *  TMP2 (!) = ROM/RAM source address
0018               *  TMP3 (!) = Length of RLE encoded data
0019               *--------------------------------------------------------------
0020               *  Detail on RLE compression format:
0021               *  - If high bit is set, remaining 7 bits indicate to copy
0022               *    the next byte that many times.
0023               *  - If high bit is clear, remaining 7 bits indicate how many
0024               *    data bytes (non-repeated) follow.
0025               ********@*****@*********************@**************************
0026 60AA C1BB  30 rle2v   mov   *r11+,tmp2            ; ROM/RAM source address
0027 60AC C13B  30         mov   *r11+,tmp0            ; VDP target address
0028 60AE C1FB  30         mov   *r11+,tmp3            ; Length of RLE encoded data
0029 60B0 C80B  38         mov   r11,@waux1            ; Save return address
     60B2 833C 
0030 60B4 06A0  32 rle2vx  bl    @vdwa                 ; Setup VDP address from TMP0
     60B6 60F0 
0031 60B8 C106  18         mov   tmp2,tmp0             ; We can safely reuse TMP0 now
0032 60BA D1B4  28 rle2v0  movb  *tmp0+,tmp2           ; Get control byte into TMP2
0033 60BC 0607  14         dec   tmp3                  ; Update length
0034 60BE 1314  14         jeq   rle2vz                ; End of list
0035 60C0 0A16  56         sla   tmp2,1                ; Check bit 0 of control byte
0036 60C2 1808  14         joc   rle2v2                ; Yes, next byte is compressed
0037               *--------------------------------------------------------------
0038               *    Dump uncompressed bytes
0039               *--------------------------------------------------------------
0040 60C4 C820  54 rle2v1  mov   @rledat,@mcloop       ; Setup machine code (MOVB *TMP0+,*R15)
     60C6 60EE 
     60C8 8320 
0041 60CA 0996  56         srl   tmp2,9                ; Use control byte as counter
0042 60CC 61C6  18         s     tmp2,tmp3             ; Update length
0043 60CE 06A0  32         bl    @mcloop               ; Write data to VDP
     60D0 8320 
0044 60D2 1008  14         jmp   rle2v3
0045               *--------------------------------------------------------------
0046               *    Dump compressed bytes
0047               *--------------------------------------------------------------
0048 60D4 C820  54 rle2v2  mov   @filzz,@mcloop        ; Setup machine code(MOVB TMP1,*R15)
     60D6 1624 
     60D8 8320 
0049 60DA 0996  56         srl   tmp2,9                ; Use control byte as counter
0050 60DC 0607  14         dec   tmp3                  ; Update length
0051 60DE D174  28         movb  *tmp0+,tmp1           ; Byte to fill
0052 60E0 06A0  32         bl    @mcloop               ; Write data to VDP
     60E2 8320 
0053               *--------------------------------------------------------------
0054               *    Check if more data to decompress
0055               *--------------------------------------------------------------
0056 60E4 C1C7  18 rle2v3  mov   tmp3,tmp3             ; Length counter = 0 ?
0057 60E6 16E9  14         jne   rle2v0                ; Not yet, process data
0058               *--------------------------------------------------------------
0059               *    Exit
0060               *--------------------------------------------------------------
0061 60E8 C2E0  34 rle2vz  mov   @waux1,r11
     60EA 833C 
0062 60EC 045B  20         b     *r11                  ; Return
0063 60EE D7F4     rledat  data  >d7f4                 ; MOVB *TMP0+,*R15
**** **** ****     > runlib.asm
0624               
0625               
0626               *//////////////////////////////////////////////////////////////
0627               *                      VDP LOW LEVEL FUNCTIONS
0628               *//////////////////////////////////////////////////////////////
0629               
0630               ***************************************************************
0631               * VDWA / VDRA - Setup VDP write or read address
0632               ***************************************************************
0633               *  BL   @VDWA
0634               *
0635               *  TMP0 = VDP destination address for write
0636               *--------------------------------------------------------------
0637               *  BL   @VDRA
0638               *
0639               *  TMP0 = VDP source address for read
0640               ********@*****@*********************@**************************
0641 60F0 0264  22 vdwa    ori   tmp0,>4000            ; Prepare VDP address for write
     60F2 4000 
0642 60F4 06C4  14 vdra    swpb  tmp0
0643 60F6 D804  38         movb  tmp0,@vdpa
     60F8 8C02 
0644 60FA 06C4  14         swpb  tmp0
0645 60FC D804  38         movb  tmp0,@vdpa            ; Set VDP address
     60FE 8C02 
0646 6100 045B  20         b     *r11
0647               
0648               ***************************************************************
0649               * VPUTB - VDP put single byte
0650               ***************************************************************
0651               *  BL @VPUTB
0652               *  DATA P0,P1
0653               *--------------------------------------------------------------
0654               *  P0 = VDP target address
0655               *  P1 = Byte to write
0656               ********@*****@*********************@**************************
0657 6102 C13B  30 vputb   mov   *r11+,tmp0            ; Get VDP target address
0658 6104 C17B  30         mov   *r11+,tmp1
0659 6106 C18B  18 xvputb  mov   r11,tmp2              ; Save R11
0660 6108 06A0  32         bl    @vdwa                 ; Set VDP write address
     610A 60F0 
0661               
0662 610C 06C5  14         swpb  tmp1                  ; Get byte to write
0663 610E D7C5  30         movb  tmp1,*r15             ; Write byte
0664 6110 0456  20         b     *tmp2                 ; Exit
0665               
0666               
0667               ***************************************************************
0668               * VGETB - VDP get single byte
0669               ***************************************************************
0670               *  BL @VGETB
0671               *  DATA P0
0672               *--------------------------------------------------------------
0673               *  P0 = VDP source address
0674               ********@*****@*********************@**************************
0675 6112 C13B  30 vgetb   mov   *r11+,tmp0            ; Get VDP source address
0676 6114 C18B  18 xvgetb  mov   r11,tmp2              ; Save R11
0677 6116 06A0  32         bl    @vdra                 ; Set VDP read address
     6118 60F4 
0678               
0679 611A D120  34         movb  @vdpr,tmp0            ; Read byte
     611C 8800 
0680               
0681 611E 0984  56         srl   tmp0,8                ; Right align
0682 6120 0456  20         b     *tmp2                 ; Exit
0683               
0684               ***************************************************************
0685               * VIDTAB - Dump videomode table
0686               ***************************************************************
0687               *  BL   @VIDTAB
0688               *  DATA P0
0689               *--------------------------------------------------------------
0690               *  P0 = Address of video mode table
0691               *--------------------------------------------------------------
0692               *  BL   @XIDTAB
0693               *
0694               *  TMP0 = Address of video mode table
0695               *--------------------------------------------------------------
0696               *  Remarks
0697               *  TMP1 = MSB is the VDP target register
0698               *         LSB is the value to write
0699               ********@*****@*********************@**************************
0700 6122 C13B  30 vidtab  mov   *r11+,tmp0            ; Get video mode table
0701 6124 C394  26 xidtab  mov   *tmp0,r14             ; Store copy of VDP#0 and #1 in RAM
0702               *--------------------------------------------------------------
0703               * Calculate PNT base address
0704               *--------------------------------------------------------------
0705 6126 C144  18         mov   tmp0,tmp1
0706 6128 05C5  14         inct  tmp1
0707 612A D155  26         movb  *tmp1,tmp1            ; Get value for VDP#2
0708 612C 0245  22         andi  tmp1,>ff00            ; Only keep MSB
     612E FF00 
0709 6130 0A25  56         sla   tmp1,2                ; TMP1 *= 400
0710 6132 C805  38         mov   tmp1,@wbase           ; Store calculated base
     6134 8328 
0711               *--------------------------------------------------------------
0712               * Dump VDP shadow registers
0713               *--------------------------------------------------------------
0714 6136 0205  20         li    tmp1,>8000            ; Start with VDP register 0
     6138 8000 
0715 613A 0206  20         li    tmp2,8
     613C 0008 
0716 613E D834  48 vidta1  movb  *tmp0+,@tmp1lb        ; Write value to VDP register
     6140 830B 
0717 6142 06C5  14         swpb  tmp1
0718 6144 D805  38         movb  tmp1,@vdpa
     6146 8C02 
0719 6148 06C5  14         swpb  tmp1
0720 614A D805  38         movb  tmp1,@vdpa
     614C 8C02 
0721 614E 0225  22         ai    tmp1,>0100
     6150 0100 
0722 6152 0606  14         dec   tmp2
0723 6154 16F4  14         jne   vidta1                ; Next register
0724 6156 C814  46         mov   *tmp0,@wcolmn         ; Store # of columns per row
     6158 833A 
0725 615A 045B  20         b     *r11
0726               
0727               
0728               ***************************************************************
0729               * PUTVR  - Put single VDP register
0730               ***************************************************************
0731               *  BL   @PUTVR
0732               *  DATA P0
0733               *--------------------------------------------------------------
0734               *  P0 = MSB is the VDP target register
0735               *       LSB is the value to write
0736               *--------------------------------------------------------------
0737               *  BL   @PUTVRX
0738               *
0739               *  TMP0 = MSB is the VDP target register
0740               *         LSB is the value to write
0741               ********@*****@*********************@**************************
0742 615C C13B  30 putvr   mov   *r11+,tmp0
0743 615E 0264  22 putvrx  ori   tmp0,>8000
     6160 8000 
0744 6162 06C4  14         swpb  tmp0
0745 6164 D804  38         movb  tmp0,@vdpa
     6166 8C02 
0746 6168 06C4  14         swpb  tmp0
0747 616A D804  38         movb  tmp0,@vdpa
     616C 8C02 
0748 616E 045B  20         b     *r11
0749               
0750               ***************************************************************
0751               * PUTV01  - Put VDP registers #0 and #1
0752               ***************************************************************
0753               *  BL   @PUTV01
0754               ********@*****@*********************@**************************
0755 6170 C20B  18 putv01  mov   r11,tmp4              ; Save R11
0756 6172 C10E  18         mov   r14,tmp0
0757 6174 0984  56         srl   tmp0,8
0758 6176 06A0  32         bl    @putvrx               ; Write VR#0
     6178 615E 
0759 617A 0204  20         li    tmp0,>0100
     617C 0100 
0760 617E D820  54         movb  @r14lb,@tmp0lb
     6180 831D 
     6182 8309 
0761 6184 06A0  32         bl    @putvrx               ; Write VR#1
     6186 615E 
0762 6188 0458  20         b     *tmp4                 ; Exit
0763               
0764               *//////////////////////////////////////////////////////////////
0765               *            VDP interrupt & screen on/off
0766               *//////////////////////////////////////////////////////////////
0770               
0771               ***************************************************************
0772               * SMAG1X - Set sprite magnification 1x
0773               ***************************************************************
0774               *  BL @SMAG1X
0775               ********@*****@*********************@**************************
0776 618A 024E  22 smag1x  andi  r14,>fffe             ; VDP#R1 bit 7=0 (Sprite magnification 1x)
     618C FFFE 
0777 618E 10F0  14         jmp   putv01
0778               
0779               ***************************************************************
0780               * SMAG2X - Set sprite magnification 2x
0781               ***************************************************************
0782               *  BL @SMAG2X
0783               ********@*****@*********************@**************************
0784 6190 026E  22 smag2x  ori   r14,>0001             ; VDP#R1 bit 7=1 (Sprite magnification 2x)
     6192 0001 
0785 6194 10ED  14         jmp   putv01
0786               
0787               ***************************************************************
0788               * S8X8 - Set sprite size 8x8 bits
0789               ***************************************************************
0790               *  BL @S8X8
0791               ********@*****@*********************@**************************
0792 6196 024E  22 s8x8    andi  r14,>fffd             ; VDP#R1 bit 6=0 (Sprite size 8x8)
     6198 FFFD 
0793 619A 10EA  14         jmp   putv01
0794               
0795               ***************************************************************
0796               * S16X16 - Set sprite size 16x16 bits
0797               ***************************************************************
0798               *  BL @S16X16
0799               ********@*****@*********************@**************************
0800 619C 026E  22 s16x16  ori   r14,>0002             ; VDP#R1 bit 6=1 (Sprite size 16x16)
     619E 0002 
0801 61A0 10E7  14         jmp   putv01
0802               
0803               ***************************************************************
0804               * YX2PNT - Get VDP PNT address for current YX cursor position
0805               ***************************************************************
0806               *  BL   @YX2PNT
0807               *--------------------------------------------------------------
0808               *  INPUT
0809               *  @WYX = Cursor YX position
0810               *--------------------------------------------------------------
0811               *  OUTPUT
0812               *  TMP0 = VDP address for entry in Pattern Name Table
0813               *--------------------------------------------------------------
0814               *  Register usage
0815               *  TMP0, R14, R15
0816               ********@*****@*********************@**************************
0817 61A2 C10E  18 yx2pnt  mov   r14,tmp0              ; Save VDP#0 & VDP#1
0818 61A4 C3A0  34         mov   @wyx,r14              ; Get YX
     61A6 832A 
0819 61A8 098E  56         srl   r14,8                 ; Right justify (remove X)
0820 61AA 3BA0  72         mpy   @wcolmn,r14           ; pos = Y * (columns per row)
     61AC 833A 
0821               *--------------------------------------------------------------
0822               * Do rest of calculation with R15 (16 bit part is there)
0823               * Re-use R14
0824               *--------------------------------------------------------------
0825 61AE C3A0  34         mov   @wyx,r14              ; Get YX
     61B0 832A 
0826 61B2 024E  22         andi  r14,>00ff             ; Remove Y
     61B4 00FF 
0827 61B6 A3CE  18         a     r14,r15               ; pos = pos + X
0828 61B8 A3E0  34         a     @wbase,r15            ; pos = pos + (PNT base address)
     61BA 8328 
0829               *--------------------------------------------------------------
0830               * Clean up before exit
0831               *--------------------------------------------------------------
0832 61BC C384  18         mov   tmp0,r14              ; Restore VDP#0 & VDP#1
0833 61BE C10F  18         mov   r15,tmp0              ; Return pos in TMP0
0834 61C0 020F  20         li    r15,vdpw              ; VDP write address
     61C2 8C00 
0835 61C4 045B  20         b     *r11
0836               
0837               
0838               *//////////////////////////////////////////////////////////////
0839               *         VDP calculate pixel position for YX coordinate
0840               *//////////////////////////////////////////////////////////////
0844               
0845               *//////////////////////////////////////////////////////////////
0846               *         VDP calculate YX coordinate for pixel position
0847               *//////////////////////////////////////////////////////////////
0849                       copy  "vdp_px2yx_calc.asm"
**** **** ****     > vdp_px2yx_calc.asm
0001               * FILE......: vdp_px2yx_calc.asm
0002               * Purpose...: Calculate YX coordinate for pixel position
0003               
0004               ***************************************************************
0005               * PX2YX - Get YX tile position for specified YX pixel position
0006               ***************************************************************
0007               *  BL   @PX2YX
0008               *--------------------------------------------------------------
0009               *  INPUT
0010               *  TMP0   = Pixel YX position
0011               *
0012               *  (CONFIG:0 = 1) = Skip sprite adjustment
0013               *--------------------------------------------------------------
0014               *  OUTPUT
0015               *  TMP0HB = Y tile position
0016               *  TMP0LB = X tile position
0017               *  TMP1HB = Y pixel offset
0018               *  TMP1LB = X pixel offset
0019               *--------------------------------------------------------------
0020               *  Remarks
0021               *  This subroutine does not support multicolor or text mode
0022               ********@*****@*********************@**************************
0023 61C6 2320  38 px2yx   coc   @wbit0,config         ; Skip sprite adjustment ?
     61C8 06A6 
0024 61CA 1302  14         jeq   px2yx1
0025 61CC 0224  22         ai    tmp0,>0100            ; Adjust Y. Top of screen is at >FF
     61CE 0100 
0026 61D0 C144  18 px2yx1  mov   tmp0,tmp1             ; Copy YX
0027 61D2 C184  18         mov   tmp0,tmp2             ; Copy YX
0028               *--------------------------------------------------------------
0029               * Calculate Y tile position
0030               *--------------------------------------------------------------
0031 61D4 09B4  56         srl   tmp0,11               ; Y: Move to TMP0LB & (Y = Y / 8)
0032               *--------------------------------------------------------------
0033               * Calculate Y pixel offset
0034               *--------------------------------------------------------------
0035 61D6 C1C4  18         mov   tmp0,tmp3             ; Y: Copy Y tile to TMP3LB
0036 61D8 0AB7  56         sla   tmp3,11               ; Y: Move to TMP3HB & (Y = Y * 8)
0037 61DA 0507  16         neg   tmp3
0038 61DC B1C5  18         ab    tmp1,tmp3             ; Y: offset = Y pixel old + (-Y) pixel new
0039               *--------------------------------------------------------------
0040               * Calculate X tile position
0041               *--------------------------------------------------------------
0042 61DE 0245  22         andi  tmp1,>00ff            ; Clear TMP1HB
     61E0 00FF 
0043 61E2 0A55  56         sla   tmp1,5                ; X: Move to TMP1HB & (X = X / 8)
0044 61E4 D105  18         movb  tmp1,tmp0             ; X: TMP0 <-- XY tile position
0045 61E6 06C4  14         swpb  tmp0                  ; XY tile position <-> YX tile position
0046               *--------------------------------------------------------------
0047               * Calculate X pixel offset
0048               *--------------------------------------------------------------
0049 61E8 0245  22         andi  tmp1,>ff00            ; X: Get rid of remaining junk in TMP1LB
     61EA FF00 
0050 61EC 0A35  56         sla   tmp1,3                ; X: (X = X * 8)
0051 61EE 0505  16         neg   tmp1
0052 61F0 06C6  14         swpb  tmp2                  ; YX <-> XY
0053 61F2 B146  18         ab    tmp2,tmp1             ; offset X = X pixel old  + (-X) pixel new
0054 61F4 06C5  14         swpb  tmp1                  ; X0 <-> 0X
0055 61F6 D147  18         movb  tmp3,tmp1             ; 0X --> YX
0056 61F8 045B  20         b     *r11                  ; Exit
**** **** ****     > runlib.asm
0851               
0852               *//////////////////////////////////////////////////////////////
0853               *                    VDP BITMAP FUNCTIONS
0854               *//////////////////////////////////////////////////////////////
0859               
0860               *//////////////////////////////////////////////////////////////
0861               *                 VDP F18A LOW-LEVEL FUNCTIONS
0862               *//////////////////////////////////////////////////////////////
0867               
0868               *//////////////////////////////////////////////////////////////
0869               *                      VDP TILE FUNCTIONS
0870               *//////////////////////////////////////////////////////////////
0871               
0872               ***************************************************************
0873               * LDFNT - Load TI-99/4A font from GROM into VDP
0874               ***************************************************************
0875               *  BL   @LDFNT
0876               *  DATA P0,P1
0877               *--------------------------------------------------------------
0878               *  P0 = VDP Target address
0879               *  P1 = Font options
0880               ********@*****@*********************@**************************
0881 61FA C20B  18 ldfnt   mov   r11,tmp4              ; Save R11
0882 61FC 05CB  14         inct  r11                   ; Get 2nd parameter (font options)
0883 61FE C11B  26         mov   *r11,tmp0             ; Get P0
0884 6200 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     6202 7FFF 
0885 6204 2120  38         coc   @wbit0,tmp0
     6206 06A6 
0886 6208 1604  14         jne   ldfnt1
0887 620A 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     620C 8000 
0888 620E 0244  22         andi  tmp0,>7fff            ; Parameter value bit 0=0
     6210 7FFF 
0889               *--------------------------------------------------------------
0890               * Read font table address from GROM into tmp1
0891               *--------------------------------------------------------------
0892 6212 C124  34 ldfnt1  mov   @tmp006(tmp0),tmp0    ; Load GROM index address into tmp0
     6214 627C 
0893 6216 D804  38         movb  tmp0,@grmwa           ; Setup GROM source byte 1 for reading
     6218 9C02 
0894 621A 06C4  14         swpb  tmp0
0895 621C D804  38         movb  tmp0,@grmwa           ; Setup GROM source byte 2 for reading
     621E 9C02 
0896 6220 D160  34         movb  @grmrd,tmp1           ; Read font table address byte 1
     6222 9800 
0897 6224 06C5  14         swpb  tmp1
0898 6226 D160  34         movb  @grmrd,tmp1           ; Read font table address byte 2
     6228 9800 
0899 622A 06C5  14         swpb  tmp1
0900               *--------------------------------------------------------------
0901               * Setup GROM source address from tmp1
0902               *--------------------------------------------------------------
0903 622C D805  38         movb  tmp1,@grmwa
     622E 9C02 
0904 6230 06C5  14         swpb  tmp1
0905 6232 D805  38         movb  tmp1,@grmwa           ; Setup GROM address for reading
     6234 9C02 
0906               *--------------------------------------------------------------
0907               * Setup VDP target address
0908               *--------------------------------------------------------------
0909 6236 C118  26         mov   *tmp4,tmp0            ; Get P1 (VDP destination)
0910 6238 06A0  32         bl    @vdwa                 ; Setup VDP destination address
     623A 60F0 
0911 623C 05C8  14         inct  tmp4                  ; R11=R11+2
0912 623E C158  26         mov   *tmp4,tmp1            ; Get font options into TMP1
0913 6240 0245  22         andi  tmp1,>7fff            ; Parameter value bit 0=0
     6242 7FFF 
0914 6244 C1A5  34         mov   @tmp006+2(tmp1),tmp2  ; Get number of patterns to copy
     6246 627E 
0915 6248 C165  34         mov   @tmp006+4(tmp1),tmp1  ; 7 or 8 byte pattern ?
     624A 6280 
0916               *--------------------------------------------------------------
0917               * Copy from GROM to VRAM
0918               *--------------------------------------------------------------
0919 624C 0B15  56 ldfnt2  src   tmp1,1                ; Carry set ?
0920 624E 1812  14         joc   ldfnt4                ; Yes, go insert a >00
0921 6250 D120  34         movb  @grmrd,tmp0
     6252 9800 
0922               *--------------------------------------------------------------
0923               *   Make font fat
0924               *--------------------------------------------------------------
0925 6254 2320  38         coc   @wbit0,config         ; Fat flag set ?
     6256 06A6 
0926 6258 1603  14         jne   ldfnt3                ; No, so skip
0927 625A D3C4  18         movb  tmp0,tmp6
0928 625C 091F  56         srl   tmp6,1
0929 625E E10F  18         soc   tmp6,tmp0
0930               *--------------------------------------------------------------
0931               *   Dump byte to VDP and do housekeeping
0932               *--------------------------------------------------------------
0933 6260 D804  38 ldfnt3  movb  tmp0,@vdpw            ; Dump byte to VRAM
     6262 8C00 
0934 6264 0606  14         dec   tmp2
0935 6266 16F2  14         jne   ldfnt2
0936 6268 05C8  14         inct  tmp4                  ; R11=R11+2
0937 626A 020F  20         li    r15,vdpw              ; Set VDP write address
     626C 8C00 
0938 626E 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     6270 7FFF 
0939 6272 0458  20         b     *tmp4                 ; Exit
0940 6274 D820  54 ldfnt4  movb  @bd0,@vdpw            ; Insert byte >00 into VRAM
     6276 0002 
     6278 8C00 
0941 627A 10E8  14         jmp   ldfnt2
0942               *--------------------------------------------------------------
0943               * Fonts pointer table
0944               *--------------------------------------------------------------
0945 627C 004C     tmp006  data  >004c,64*8,>0000      ; Pointer to TI title screen font
     627E 0200 
     6280 0000 
0946 6282 004E             data  >004e,64*7,>0101      ; Pointer to upper case font
     6284 01C0 
     6286 0101 
0947 6288 004E             data  >004e,96*7,>0101      ; Pointer to upper & lower case font
     628A 02A0 
     628C 0101 
0948 628E 0050             data  >0050,32*7,>0101      ; Pointer to lower case font
     6290 00E0 
     6292 0101 
0949               
0950               
0951               ***************************************************************
0952               * Put length-byte prefixed string at current YX
0953               ***************************************************************
0954               *  BL   @PUTSTR
0955               *  DATA P0
0956               *
0957               *  P0 = Pointer to string
0958               *--------------------------------------------------------------
0959               *  REMARKS
0960               *  First byte of string must contain length
0961               ********@*****@*********************@**************************
0962 6294 C17B  30 putstr  mov   *r11+,tmp1
0963 6296 D1B5  28 xutst0  movb  *tmp1+,tmp2           ; Get length byte
0964 6298 C1CB  18 xutstr  mov   r11,tmp3
0965 629A 06A0  32         bl    @yx2pnt               ; Get VDP destination address
     629C 61A2 
0966 629E C2C7  18         mov   tmp3,r11
0967 62A0 0986  56         srl   tmp2,8                ; Right justify length byte
0968 62A2 0460  28         b     @xpym2v               ; Display string
     62A4 608A 
0969               
0970               
0971               ***************************************************************
0972               * Put length-byte prefixed string at YX
0973               ***************************************************************
0974               *  BL   @PUTAT
0975               *  DATA P0,P1
0976               *
0977               *  P0 = YX position
0978               *  P1 = Pointer to string
0979               *--------------------------------------------------------------
0980               *  REMARKS
0981               *  First byte of string must contain length
0982               ********@*****@*********************@**************************
0983 62A6 C83B  50 putat   mov   *r11+,@wyx            ; Set YX position
     62A8 832A 
0984 62AA 0460  28         b     @putstr
     62AC 6294 
0985               
0986               
0987               *//////////////////////////////////////////////////////////////
0988               *                   VDP hchar functions
0989               *//////////////////////////////////////////////////////////////
0991                       copy  "vdp_hchar.asm"
**** **** ****     > vdp_hchar.asm
0001               * FILE......: vdp_hchar.a99
0002               * Purpose...: VDP hchar module
0003               
0004               ***************************************************************
0005               * Repeat characters horizontally at YX
0006               ***************************************************************
0007               *  BL    @HCHAR
0008               *  DATA  P0,P1
0009               *  ...
0010               *  DATA  EOL                        ; End-of-list
0011               *--------------------------------------------------------------
0012               *  P0HB = Y position
0013               *  P0LB = X position
0014               *  P1HB = Byte to write
0015               *  P1LB = Number of times to repeat
0016               ********@*****@*********************@**************************
0017 62AE C83B  50 hchar   mov   *r11+,@wyx            ; Set YX position
     62B0 832A 
0018 62B2 D17B  28         movb  *r11+,tmp1
0019 62B4 0985  56 hcharx  srl   tmp1,8                ; Byte to write
0020 62B6 D1BB  28         movb  *r11+,tmp2
0021 62B8 0986  56         srl   tmp2,8                ; Repeat count
0022 62BA C1CB  18         mov   r11,tmp3
0023 62BC 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     62BE 61A2 
0024               *--------------------------------------------------------------
0025               *    Draw line
0026               *--------------------------------------------------------------
0027 62C0 020B  20         li    r11,hchar1
     62C2 62C8 
0028 62C4 0460  28         b     @xfilv                ; Draw
     62C6 6064 
0029               *--------------------------------------------------------------
0030               *    Do housekeeping
0031               *--------------------------------------------------------------
0032 62C8 8817  46 hchar1  c     *tmp3,@whffff         ; End-Of-List marker found ?
     62CA 0E2C 
0033 62CC 1302  14         jeq   hchar2                ; Yes, exit
0034 62CE C2C7  18         mov   tmp3,r11
0035 62D0 10EE  14         jmp   hchar                 ; Next one
0036 62D2 05C7  14 hchar2  inct  tmp3
0037 62D4 0457  20         b     *tmp3                 ; Exit
**** **** ****     > runlib.asm
0993               
0994               *//////////////////////////////////////////////////////////////
0995               *                   VDP vchar functions
0996               *//////////////////////////////////////////////////////////////
0998                       copy  "vdp_vchar.asm"
**** **** ****     > vdp_vchar.asm
0001               * FILE......: vdp_vchar.a99
0002               * Purpose...: VDP vchar module
0003               
0004               ***************************************************************
0005               * Repeat characters vertically at YX
0006               ***************************************************************
0007               *  BL    @VCHAR
0008               *  DATA  P0,P1
0009               *  ...
0010               *  DATA  EOL                        ; End-of-list
0011               *--------------------------------------------------------------
0012               *  P0HB = Y position
0013               *  P0LB = X position
0014               *  P1HB = Byte to write
0015               *  P1LB = Number of times to repeat
0016               ********@*****@*********************@**************************
0017 62D6 C83B  50 vchar   mov   *r11+,@wyx            ; Set YX position
     62D8 832A 
0018 62DA C1CB  18         mov   r11,tmp3              ; Save R11 in TMP3
0019 62DC C220  34 vchar1  mov   @wcolmn,tmp4          ; Get columns per row
     62DE 833A 
0020 62E0 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     62E2 61A2 
0021 62E4 D177  28         movb  *tmp3+,tmp1           ; Byte to write
0022 62E6 D1B7  28         movb  *tmp3+,tmp2
0023 62E8 0986  56         srl   tmp2,8                ; Repeat count
0024               *--------------------------------------------------------------
0025               *    Setup VDP write address
0026               *--------------------------------------------------------------
0027 62EA 06A0  32 vchar2  bl    @vdwa                 ; Setup VDP write address
     62EC 60F0 
0028               *--------------------------------------------------------------
0029               *    Dump tile to VDP and do housekeeping
0030               *--------------------------------------------------------------
0031 62EE D7C5  30         movb  tmp1,*r15             ; Dump tile to VDP
0032 62F0 A108  18         a     tmp4,tmp0             ; Next row
0033 62F2 0606  14         dec   tmp2
0034 62F4 16FA  14         jne   vchar2
0035 62F6 8817  46         c     *tmp3,@whffff         ; End-Of-List marker found ?
     62F8 0E2C 
0036 62FA 1303  14         jeq   vchar3                ; Yes, exit
0037 62FC C837  50         mov   *tmp3+,@wyx           ; Save YX position
     62FE 832A 
0038 6300 10ED  14         jmp   vchar1                ; Next one
0039 6302 05C7  14 vchar3  inct  tmp3
0040 6304 0457  20         b     *tmp3                 ; Exit
0041               
0042               ***************************************************************
0043               * Repeat characters vertically at YX
0044               ***************************************************************
0045               * TMP0 = YX position
0046               * TMP1 = Byte to write
0047               * TMP2 = Repeat count
0048               ***************************************************************
0049 6306 C20B  18 xvchar  mov   r11,tmp4              ; Save return address
0050 6308 C804  38         mov   tmp0,@wyx             ; Set cursor position
     630A 832A 
0051 630C 06C5  14         swpb  tmp1                  ; Byte to write into MSB
0052 630E C1E0  34         mov   @wcolmn,tmp3          ; Get columns per row
     6310 833A 
0053 6312 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     6314 61A2 
0054               *--------------------------------------------------------------
0055               *    Setup VDP write address
0056               *--------------------------------------------------------------
0057 6316 06A0  32 xvcha1  bl    @vdwa                 ; Setup VDP write address
     6318 60F0 
0058               *--------------------------------------------------------------
0059               *    Dump tile to VDP and do housekeeping
0060               *--------------------------------------------------------------
0061 631A D7C5  30         movb  tmp1,*r15             ; Dump tile to VDP
0062 631C A120  34         a     @wcolmn,tmp0          ; Next row
     631E 833A 
0063 6320 0606  14         dec   tmp2
0064 6322 16F9  14         jne   xvcha1
0065 6324 0458  20         b     *tmp4                 ; Exit
**** **** ****     > runlib.asm
1000               
1001               *//////////////////////////////////////////////////////////////
1002               *                    VDP box functions
1003               *//////////////////////////////////////////////////////////////
1007               
1008               *//////////////////////////////////////////////////////////////
1009               *                VDP unsigned numbers support
1010               *//////////////////////////////////////////////////////////////
1012                       copy  "vdp_numsupport.asm"
**** **** ****     > vdp_numsupport.asm
0001               * FILE......: vdp_numsupport.asm
0002               * Purpose...: VDP create, display numbers module
0003               
0004               ***************************************************************
0005               * MKNUM - Convert unsigned number to string
0006               ***************************************************************
0007               *  BL   @MKNUM
0008               *  DATA P0,P1,P2
0009               *
0010               *  P0   = Pointer to 16 bit unsigned number
0011               *  P1   = Pointer to 5 byte string buffer
0012               *  P2HB = Offset for ASCII digit
0013               *  P2LB = Character for replacing leading 0's
0014               *
0015               *  (CONFIG:0 = 1) = Display number at cursor YX
0016               ********@*****@*********************@**************************
0017 6326 0207  20 mknum   li    tmp3,5                ; Digit counter
     6328 0005 
0018 632A C17B  30         mov   *r11+,tmp1            ; \ Get 16 bit unsigned number
0019 632C C155  26         mov   *tmp1,tmp1            ; /
0020 632E C23B  30         mov   *r11+,tmp4            ; Pointer to string buffer
0021 6330 0228  22         ai    tmp4,4                ; Get end of buffer
     6332 0004 
0022 6334 0206  20         li    tmp2,10               ; Divide by 10 to isolate last digit
     6336 000A 
0023               *--------------------------------------------------------------
0024               *  Do string conversion
0025               *--------------------------------------------------------------
0026 6338 04C4  14 mknum1  clr   tmp0                  ; Clear the high word of the dividend
0027 633A 3D06  128         div   tmp2,tmp0             ; (TMP0:TMP1) / 10 (TMP2)
0028 633C 06C5  14         swpb  tmp1                  ; Move to high-byte for writing to buffer
0029 633E B15B  26         ab    *r11,tmp1             ; Add offset for ASCII digit
0030 6340 D605  30         movb  tmp1,*tmp4            ; Write remainder to string buffer
0031 6342 C144  18         mov   tmp0,tmp1             ; Move integer result into R4 for the next digit
0032 6344 0608  14         dec   tmp4                  ; Adjust string pointer for next digit
0033 6346 0607  14         dec   tmp3                  ; Decrease counter
0034 6348 16F7  14         jne   mknum1                ; Do next digit
0035               *--------------------------------------------------------------
0036               *  Replace leading 0's with fill character
0037               *--------------------------------------------------------------
0038 634A 0207  20         li    tmp3,4                ; Check first 4 digits
     634C 0004 
0039 634E 0588  14         inc   tmp4                  ; Too far, back to buffer start
0040 6350 C11B  26         mov   *r11,tmp0
0041 6352 0A84  56         sla   tmp0,8                ; Only keep fill character in HB
0042 6354 96D8  38 mknum2  cb    *tmp4,*r11            ; Digit = 0 ?
0043 6356 1305  14         jeq   mknum4                ; Yes, replace with fill character
0044 6358 05CB  14 mknum3  inct  r11
0045 635A 2320  38         coc   @wbit0,config         ; Check if 'display' bit is set
     635C 06A6 
0046 635E 1305  14         jeq   mknum5                ; Yes, so show at current YX position
0047 6360 045B  20         b     *r11                  ; Exit
0048 6362 DE04  32 mknum4  movb  tmp0,*tmp4+           ; Replace leading 0 with fill character
0049 6364 0607  14         dec   tmp3                  ; 4th digit processed ?
0050 6366 13F8  14         jeq   mknum3                ; Yes, exit
0051 6368 10F5  14         jmp   mknum2                ; No, next one
0052               *--------------------------------------------------------------
0053               *  Display integer on screen at current YX position
0054               *--------------------------------------------------------------
0055 636A 024C  22 mknum5  andi  config,>7fff          ; Reset bit 0
     636C 7FFF 
0056 636E C10B  18         mov   r11,tmp0
0057 6370 0224  22         ai    tmp0,-4
     6372 FFFC 
0058 6374 C154  26         mov   *tmp0,tmp1            ; Get buffer address
0059 6376 0206  20         li    tmp2,>0500            ; String length = 5
     6378 0500 
0060 637A 0460  28         b     @xutstr               ; Display string
     637C 6298 
0061               
0062               
0063               ***************************************************************
0064               * PUTNUM - Put unsigned number on screen
0065               ***************************************************************
0066               *  BL   @PUTNUM
0067               *  DATA P0,P1,P2,P3
0068               *--------------------------------------------------------------
0069               *  P0   = YX position
0070               *  P1   = Pointer to 16 bit unsigned number
0071               *  P2   = Pointer to 5 byte string buffer
0072               *  P3HB = Offset for ASCII digit
0073               *  P3LB = Character for replacing leading 0's
0074               ********@*****@*********************@**************************
0075 637E C83B  50 putnum  mov   *r11+,@wyx            ; Set cursor
     6380 832A 
0076 6382 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     6384 8000 
0077 6386 10CF  14         jmp   mknum                 ; Convert number and display
**** **** ****     > runlib.asm
1014               
1015               *//////////////////////////////////////////////////////////////
1016               *                 VDP hex numbers support
1017               *//////////////////////////////////////////////////////////////
1021               
1022               *//////////////////////////////////////////////////////////////
1023               *                 VDP viewport functionality
1024               *//////////////////////////////////////////////////////////////
1028               
1029               
1030               *//////////////////////////////////////////////////////////////
1031               *                            SOUND
1032               *//////////////////////////////////////////////////////////////
1033               
1034               ***************************************************************
1035               * MUTE - Mute all sound generators
1036               ***************************************************************
1037               *  BL  @MUTE
1038               *  Mute sound generators and clear sound pointer
1039               *
1040               *  BL  @MUTE2
1041               *  Mute sound generators without clearing sound pointer
1042               ********@*****@*********************@**************************
1043 6388 04E0  34 mute    clr   @wsdlst               ; Clear sound pointer
     638A 8334 
1044 638C 4320  34 mute2   szc   @wbit13,config        ; Turn off/pause sound player
     638E 6022 
1045 6390 0204  20         li    tmp0,muttab
     6392 63A2 
1046 6394 0205  20         li    tmp1,sound            ; Sound generator port >8400
     6396 8400 
1047 6398 D574  40         movb  *tmp0+,*tmp1          ; Generator 0
1048 639A D574  40         movb  *tmp0+,*tmp1          ; Generator 1
1049 639C D574  40         movb  *tmp0+,*tmp1          ; Generator 2
1050 639E D554  38         movb  *tmp0,*tmp1           ; Generator 3
1051 63A0 045B  20         b     *r11
1052 63A2 9FBF     muttab  byte  >9f,>bf,>df,>ff       ; Table for muting all generators
     63A4 DFFF 
1053               
1054               
1055               ***************************************************************
1056               * SDPREP - Prepare for playing sound
1057               ***************************************************************
1058               *  BL   @SDPREP
1059               *  DATA P0,P1
1060               *
1061               *  P0 = Address where tune is stored
1062               *  P1 = Option flags for sound player
1063               *--------------------------------------------------------------
1064               *  REMARKS
1065               *  Use the below equates for P1:
1066               *
1067               *  SDOPT1 => Tune is in CPU memory + loop
1068               *  SDOPT2 => Tune is in CPU memory
1069               *  SDOPT3 => Tune is in VRAM + loop
1070               *  SDOPT4 => Tune is in VRAM
1071               ********@*****@*********************@**************************
1072 63A6 C81B  46 sdprep  mov   *r11,@wsdlst          ; Set tune address
     63A8 8334 
1073 63AA C83B  50         mov   *r11+,@wsdtmp         ; Set tune address in temp
     63AC 8336 
1074 63AE 024C  22         andi  r12,>fff8             ; Clear bits 13-14-15
     63B0 FFF8 
1075 63B2 E33B  30         soc   *r11+,config          ; Set options
1076 63B4 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     63B6 002A 
     63B8 831B 
1077 63BA 045B  20         b     *r11
1078               
1079               ***************************************************************
1080               * SDPLAY - Sound player for tune in VRAM or CPU memory
1081               ***************************************************************
1082               *  BL  @SDPLAY
1083               *--------------------------------------------------------------
1084               *  REMARKS
1085               *  Set config register bit13=0 to pause player.
1086               *  Set config register bit14=1 to repeat (or play next tune).
1087               ********@*****@*********************@**************************
1088 63BC 2320  38 sdplay  coc   @wbit13,config        ; Play tune ?
     63BE 6022 
1089 63C0 1301  14         jeq   sdpla1                ; Yes, play
1090 63C2 045B  20         b     *r11
1091               *--------------------------------------------------------------
1092               * Initialisation
1093               *--------------------------------------------------------------
1094 63C4 060D  14 sdpla1  dec   r13                   ; duration = duration - 1
1095 63C6 9820  54         cb    @r13lb,@bd0           ; R13LB == 0 ?
     63C8 831B 
     63CA 0002 
1096 63CC 1301  14         jeq   sdpla3                ; Play next note
1097 63CE 045B  20 sdpla2  b     *r11                  ; Note still busy, exit
1098 63D0 2320  38 sdpla3  coc   @wbit15,config        ; Play tune from CPU memory ?
     63D2 0378 
1099 63D4 131A  14         jeq   mmplay
1100               *--------------------------------------------------------------
1101               * Play tune from VDP memory
1102               *--------------------------------------------------------------
1103 63D6 C120  34 vdplay  mov   @wsdtmp,tmp0          ; Get tune address
     63D8 8336 
1104 63DA 06C4  14         swpb  tmp0
1105 63DC D804  38         movb  tmp0,@vdpa
     63DE 8C02 
1106 63E0 06C4  14         swpb  tmp0
1107 63E2 D804  38         movb  tmp0,@vdpa
     63E4 8C02 
1108 63E6 04C4  14         clr   tmp0
1109 63E8 D120  34         movb  @vdpr,tmp0            ; length = 0 (end of tune) ?
     63EA 8800 
1110 63EC 131E  14         jeq   sdexit                ; Yes. exit
1111 63EE 0984  56 vdpla1  srl   tmp0,8                ; Right justify length byte
1112 63F0 A804  38         a     tmp0,@wsdtmp          ; Adjust for next table entry
     63F2 8336 
1113 63F4 D820  54 vdpla2  movb  @vdpr,@>8400          ; Feed byte to sound generator
     63F6 8800 
     63F8 8400 
1114 63FA 0604  14         dec   tmp0
1115 63FC 16FB  14         jne   vdpla2
1116 63FE D820  54         movb  @vdpr,@r13lb          ; Set duration counter
     6400 8800 
     6402 831B 
1117 6404 05E0  34 vdpla3  inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     6406 8336 
1118 6408 045B  20         b     *r11
1119               *--------------------------------------------------------------
1120               * Play tune from CPU memory
1121               *--------------------------------------------------------------
1122 640A C120  34 mmplay  mov   @wsdtmp,tmp0
     640C 8336 
1123 640E D174  28         movb  *tmp0+,tmp1           ; length = 0 (end of tune) ?
1124 6410 130C  14         jeq   sdexit                ; Yes, exit
1125 6412 0985  56 mmpla1  srl   tmp1,8                ; Right justify length byte
1126 6414 A805  38         a     tmp1,@wsdtmp          ; Adjust for next table entry
     6416 8336 
1127 6418 D834  48 mmpla2  movb  *tmp0+,@>8400         ; Feed byte to sound generator
     641A 8400 
1128 641C 0605  14         dec   tmp1
1129 641E 16FC  14         jne   mmpla2
1130 6420 D814  46         movb  *tmp0,@r13lb          ; Set duration counter
     6422 831B 
1131 6424 05E0  34         inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     6426 8336 
1132 6428 045B  20         b     *r11
1133               *--------------------------------------------------------------
1134               * Exit. Check if tune must be looped
1135               *--------------------------------------------------------------
1136 642A 2320  38 sdexit  coc   @wbit14,config        ; Loop flag set ?
     642C 6024 
1137 642E 1607  14         jne   sdexi2                ; No, exit
1138 6430 C820  54         mov   @wsdlst,@wsdtmp
     6432 8334 
     6434 8336 
1139 6436 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     6438 002A 
     643A 831B 
1140 643C 045B  20 sdexi1  b     *r11                  ; Exit
1141 643E 024C  22 sdexi2  andi  config,>fff8          ; Reset music player
     6440 FFF8 
1142 6442 045B  20         b     *r11                  ; Exit
1143               
1144               
1145               *//////////////////////////////////////////////////////////////
1146               *                            SPEECH
1147               *//////////////////////////////////////////////////////////////
1148               
1149               ***************************************************************
1150               * SPSTAT - Read status register byte from speech synthesizer
1151               ***************************************************************
1152               *  LI  TMP2,@>....
1153               *  B   @SPSTAT
1154               *--------------------------------------------------------------
1155               * REMARKS
1156               * Destroys R11 !
1157               *
1158               * Register usage
1159               * TMP0HB = Status byte read from speech synth
1160               * TMP1   = Temporary use  (scratchpad machine code)
1161               * TMP2   = Return address for this subroutine
1162               * R11    = Return address (scratchpad machine code)
1163               ********@*****@*********************@**************************
1164 6444 0204  20 spstat  li    tmp0,spchrd           ; (R4) = >9000
     6446 9000 
1165 6448 C820  54         mov   @spcode,@mcsprd       ; \
     644A 6036 
     644C 8322 
1166 644E C820  54         mov   @spcode+2,@mcsprd+2   ; / Load speech read code
     6450 6038 
     6452 8324 
1167 6454 020B  20         li    r11,spsta1            ; Return to SPSTA1
     6456 645C 
1168 6458 0460  28         b     @mcsprd               ; Run scratchpad code
     645A 8322 
1169 645C C820  54 spsta1  mov   @mccode,@mcsprd       ; \
     645E 6030 
     6460 8322 
1170 6462 C820  54         mov   @mccode+2,@mcsprd+2   ; / Restore tight loop code
     6464 6032 
     6466 8324 
1171 6468 0456  20         b     *tmp2                 ; Exit
1172               
1173               *//////////////////////////////////////////////////////////////
1174               *        TMS52xx - Check if speech synthesizer connected
1175               *//////////////////////////////////////////////////////////////
1179               
1180               
1181               ***************************************************************
1182               * SPPREP - Prepare for playing speech
1183               ***************************************************************
1184               *  BL   @SPPREP
1185               *  DATA P0
1186               *
1187               *  P0 = Address of LPC data for external voice.
1188               ********@*****@*********************@**************************
1189 646A C83B  50 spprep  mov   *r11+,@wspeak         ; Set speech address
     646C 8338 
1190 646E E320  34         soc   @wbit3,config         ; Clear bit 3
     6470 0036 
1191 6472 045B  20         b     *r11
1192               
1193               ***************************************************************
1194               * SPPLAY - Speech player
1195               ***************************************************************
1196               * BL  @SPPLAY
1197               *--------------------------------------------------------------
1198               * Register usage
1199               * TMP3   = Copy of R11
1200               * R12    = CONFIG register
1201               ********@*****@*********************@**************************
1202 6474 2720  38 spplay  czc   @wbit3,config         ; Player off ?
     6476 0036 
1203 6478 132F  14         jeq   spplaz                ; Yes, exit
1204 647A C1CB  18 sppla1  mov   r11,tmp3              ; Save R11
1205 647C 2320  38         coc   @tmp010,config        ; Speech player enabled+busy ?
     647E 64DA 
1206 6480 1310  14         jeq   spkex3                ; Check FIFO buffer level
1207               *--------------------------------------------------------------
1208               * Speak external: Push LPC data to speech synthesizer
1209               *--------------------------------------------------------------
1210 6482 C120  34 spkext  mov   @wspeak,tmp0
     6484 8338 
1211 6486 D834  48         movb  *tmp0+,@spchwt        ; Send byte to speech synth
     6488 9400 
1212 648A 1000  14         jmp   $+2                   ; Delay
1213 648C 0206  20         li    tmp2,16
     648E 0010 
1214 6490 D834  48 spkex1  movb  *tmp0+,@spchwt        ; Send byte to speech synth
     6492 9400 
1215 6494 0606  14         dec   tmp2
1216 6496 16FC  14         jne   spkex1
1217 6498 026C  22         ori   config,>0800          ; bit 4=1 (busy)
     649A 0800 
1218 649C C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     649E 8338 
1219 64A0 101B  14         jmp   spplaz                ; Exit
1220               *--------------------------------------------------------------
1221               * Speak external: Check synth FIFO buffer level
1222               *--------------------------------------------------------------
1223 64A2 0206  20 spkex3  li    tmp2,spkex4           ; Set return address for SPSTAT
     64A4 64AA 
1224 64A6 0460  28         b     @spstat               ; Get speech FIFO buffer status
     64A8 6444 
1225 64AA 2120  38 spkex4  coc   @wh4000,tmp0          ; FIFO BL (buffer low) bit set ?
     64AC 023C 
1226 64AE 1301  14         jeq   spkex5                ; Yes, refill
1227 64B0 1013  14         jmp   spplaz                ; No, exit
1228               *--------------------------------------------------------------
1229               * Speak external: Refill synth with LPC data if FIFO buffer low
1230               *--------------------------------------------------------------
1231 64B2 C120  34 spkex5  mov   @wspeak,tmp0
     64B4 8338 
1232 64B6 0206  20         li    tmp2,8                ; Bytes to send to speech synth
     64B8 0008 
1233 64BA D174  28 spkex6  movb  *tmp0+,tmp1
1234 64BC D805  38         movb  tmp1,@spchwt          ; Send byte to speech synth
     64BE 9400 
1235 64C0 0285  22         ci    tmp1,spkoff           ; Speak off marker found ?
     64C2 FF00 
1236 64C4 1305  14         jeq   spkex8
1237 64C6 0606  14         dec   tmp2
1238 64C8 16F8  14         jne   spkex6                ; Send next byte
1239 64CA C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     64CC 8338 
1240 64CE 1004  14 spkex7  jmp   spplaz                ; Exit
1241               *--------------------------------------------------------------
1242               * Speak external: Done with speaking
1243               *--------------------------------------------------------------
1244 64D0 4320  34 spkex8  szc   @tmp010,config        ; bit 3,4,5=0
     64D2 64DA 
1245 64D4 04E0  34         clr   @wspeak               ; Reset pointer
     64D6 8338 
1246 64D8 0457  20 spplaz  b     *tmp3                 ; Exit
1247 64DA 1800     tmp010  data  >1800                 ; Binary 0001100000000000
1248                                                   ; Bit    0123456789ABCDEF
1249               
1250               *//////////////////////////////////////////////////////////////
1251               *                           KEYBOARD
1252               *//////////////////////////////////////////////////////////////
1253               
1254               
1255               *//////////////////////////////////////////////////////////////
1256               *             Keyboard support (virtual keyboard)
1257               *//////////////////////////////////////////////////////////////
1258                       copy  "keyb_virtual.asm"
**** **** ****     > keyb_virtual.asm
0001               * FILE......: keyb_virtual.asm
0002               * Purpose...: Virtual keyboard module
0003               
0004               ***************************************************************
0005               * VIRTKB - Read virtual keyboard and joysticks
0006               ***************************************************************
0007               *  BL @VIRTKB
0008               *--------------------------------------------------------------
0009               *  COLUMN     0     1  2  3  4  5    6   7
0010               *         +---------------------------------+------+
0011               *  ROW 7  |   =     .  ,  M  N  /   JS1 JS2 | Fire |
0012               *  ROW 6  | SPACE   L  K  J  H  :;  JS1 JS2 | Left |
0013               *  ROW 5  | ENTER   O  I  U  Y  P   JS1 JS2 | Right|
0014               *  ROW 4  |         9  8  7  6  0   JS1 JS2 | Down |
0015               *  ROW 3  | FCTN    2  3  4  5  1   JS1 JS2 | Up   |
0016               *  ROW 2  | SHIFT   S  D  F  G  A           +------|
0017               *  ROW 1  | CTRL    W  E  R  T  Q                  |
0018               *  ROW 0  |         X  C  V  B  Z                  |
0019               *         +----------------------------------------+
0020               *  See MG smart programmer 1986
0021               *  September/Page 15 and November/Page 6
0022               *  Also see virtual keyboard status for bits to check
0023               *--------------------------------------------------------------
0024               *  Register usage
0025               *  TMP0     Keyboard matrix column to process
0026               *  TMP1MSB  Keyboard matrix 8 bits of 1 column
0027               *  TMP2     Virtual keyboard flags
0028               *  TMP3     Address of entry in mapping table
0029               *  TMP4     Copy of R12 (CONFIG REGISTER)
0030               *  R12      CRU communication
0031               ********@*****@*********************@**************************
0032               virtkb
0033               *       szc   @wbit10,config        ; Reset alpha lock down key
0034 64DC 4320  34         szc   @wbit11,config        ; Reset ANY key
     64DE 6020 
0035 64E0 C20C  18         mov   config,tmp4           ; Save R12 (CONFIG REGISTER)
0036 64E2 04C4  14         clr   tmp0                  ; Value in MSB! Start with column 0
0037 64E4 04C6  14         clr   tmp2                  ; Erase virtual keyboard flags
0038 64E6 0207  20         li    tmp3,kbmap0           ; Start with column 0
     64E8 6558 
0039               *--------------------------------------------------------------
0040               * Check alpha lock key
0041               *-------@-----@---------------------@--------------------------
0042 64EA 04CC  14         clr   r12
0043 64EC 1E15  20         sbz   >0015                 ; Set P5
0044 64EE 1F07  20         tb    7
0045 64F0 1302  14         jeq   virtk1
0046 64F2 0206  20         li    tmp2,kalpha           ; Alpha lock key down
     64F4 8000 
0047               *       soc   @wbit10,config        ; Set alpha lock down key (CONFIG)
0048               *--------------------------------------------------------------
0049               * Scan keyboard matrix
0050               *-------@-----@---------------------@--------------------------
0051 64F6 1D15  20 virtk1  sbo   >0015                 ; Reset P5
0052 64F8 020C  20         li    r12,>0024             ; Scan full 8x8 keyboard matrix. R12 is used by LDCR
     64FA 0024 
0053 64FC 30C4  56         ldcr  tmp0,3                ; Set keyboard column with a value from 0-7 (3=3 bits)
0054 64FE 020C  20         li    r12,>0006             ; Load CRU base for row. R12 required by STCR
     6500 0006 
0055 6502 0705  14         seto  tmp1                  ; >FFFF
0056 6504 3605  64         stcr  tmp1,8                ; Bring 8 row bits into MSB of TMP1
0057 6506 0545  14         inv   tmp1
0058 6508 1302  14         jeq   virtk2                ; >0000 ?
0059 650A E220  34         soc   @wbit11,tmp4          ; Set ANY key in copy of CONFIG register
     650C 6020 
0060               *--------------------------------------------------------------
0061               * Process column
0062               *-------@-----@---------------------@--------------------------
0063 650E 2177  34 virtk2  coc   *tmp3+,tmp1           ; Check bit mask
0064 6510 1601  14         jne   virtk3
0065 6512 E197  26         soc   *tmp3,tmp2            ; Set virtual keyboard flags
0066 6514 05C7  14 virtk3  inct  tmp3
0067 6516 8817  46         c     *tmp3,@kbeoc          ; End-of-column ?
     6518 6564 
0068 651A 16F9  14         jne   virtk2                ; No, next entry
0069 651C 05C7  14         inct  tmp3
0070               *--------------------------------------------------------------
0071               * Prepare for next column
0072               *-------@-----@---------------------@--------------------------
0073 651E 0284  22 virtk4  ci    tmp0,>0700            ; Column 7 processed ?
     6520 0700 
0074 6522 1309  14         jeq   virtk6                ; Yes, exit
0075 6524 0284  22         ci    tmp0,>0200            ; Column 2 processed ?
     6526 0200 
0076 6528 1303  14         jeq   virtk5                ; Yes, skip
0077 652A 0224  22         ai    tmp0,>0100
     652C 0100 
0078 652E 10E3  14         jmp   virtk1
0079 6530 0204  20 virtk5  li    tmp0,>0500            ; Skip columns 3-4
     6532 0500 
0080 6534 10E0  14         jmp   virtk1
0081               *--------------------------------------------------------------
0082               * Exit
0083               *-------@-----@---------------------@--------------------------
0084 6536 C308  18 virtk6  mov   tmp4,config           ; Restore CONFIG register
0085 6538 C806  38         mov   tmp2,@wvrtkb          ; Save virtual keyboard flags
     653A 8332 
0086 653C 1601  14         jne   virtk7
0087 653E 045B  20         b     *r11                  ; Exit
0088 6540 0286  22 virtk7  ci    tmp2,>ffff            ; FCTN-QUIT pressed ?
     6542 FFFF 
0089 6544 1603  14         jne   virtk8                ; No
0090 6546 0701  14         seto  r1                    ; Set exit flag
0091 6548 0460  28         b     @runli1               ; Yes, reset computer
     654A 66DA 
0092 654C 0286  22 virtk8  ci    tmp2,kalpha           ; Only alpha-lock pressed ?
     654E 8000 
0093 6550 1602  14         jne   virtk9
0094 6552 4320  34         szc   @wbit11,config        ; Yes, so reset ANY key
     6554 6020 
0095 6556 045B  20 virtk9  b     *r11                  ; Exit
0096               *--------------------------------------------------------------
0097               * Mapping table
0098               *-------@-----@---------------------@--------------------------
0099               *                                   ; Bit 01234567
0100 6558 1100     kbmap0  data  >1100,>ffff           ; >11 00010001  FCTN QUIT
     655A FFFF 
0101 655C 0200             data  >0200,k1fire          ; >02 00000010  spacebar
     655E 0020 
0102 6560 0400             data  >0400,kenter          ; >04 00000100  enter
     6562 4000 
0103 6564 FFFF     kbeoc   data  >ffff
0104               
0105 6566 0800     kbmap1  data  >0800,kback           ; >08 00001000  FCTN BACK
     6568 1000 
0106 656A 0200             data  >0200,k2rg            ; >02 00000010  L (arrow right)
     656C 0008 
0107 656E 0400             data  >0400,k2up            ; >04 00000100  O (arrow up)
     6570 0004 
0108 6572 2000             data  >2000,k1lf            ; >20 00100000  S (arrow left)
     6574 0200 
0109 6576 8000             data  >8000,k1dn            ; >80 10000000  X (arrow down)
     6578 0040 
0110 657A FFFF             data  >ffff
0111               
0112 657C 0800     kbmap2  data  >0800,kredo           ; >08 00001000  FCTN REDO
     657E 2000 
0113 6580 0100             data  >0100,k2dn            ; >01 00000001  , (arrow down)
     6582 0002 
0114 6584 2000             data  >2000,k1rg            ; >20 00100000  D (arrow right)
     6586 0100 
0115 6588 4000             data  >4000,k1up            ; >80 01000000  E (arrow up)
     658A 0080 
0116 658C 0200             data  >0200,k2lf            ; >02 00000010  K (arrow left)
     658E 0010 
0117 6590 FFFF             data  >ffff
0118               
0119 6592 0100     kbcol5  data  >0100,k2fire          ; >01 00000001  / (fire)
     6594 0001 
0120 6596 0800             data  >0800,kpause          ; >08 00001000  P (pause)
     6598 0800 
0121 659A 8000             data  >8000,k1fire          ; >80 01000000  Q (fire)
     659C 0020 
0122 659E FFFF             data  >ffff
0123               
0124 65A0 0100     kbmap6  data  >0100,k1fire          ; >01 00000001  joystick 1 FIRE
     65A2 0020 
0125 65A4 0200             data  >0200,k1lf            ; >02 00000010  joystick 1 left
     65A6 0200 
0126 65A8 0400             data  >0400,k1rg            ; >04 00000100  joystick 1 right
     65AA 0100 
0127 65AC 0800             data  >0800,k1dn            ; >08 00001000  joystick 1 down
     65AE 0040 
0128 65B0 1000             data  >1000,k1up            ; >10 00010000  joystick 1 up
     65B2 0080 
0129 65B4 FFFF             data  >ffff
0130               
0131 65B6 0100     kbmap7  data  >0100,k2fire          ; >01 00000001  joystick 2 FIRE
     65B8 0001 
0132 65BA 0200             data  >0200,k2lf            ; >02 00000010  joystick 2 left
     65BC 0010 
0133 65BE 0400             data  >0400,k2rg            ; >04 00000100  joystick 2 right
     65C0 0008 
0134 65C2 0800             data  >0800,k2dn            ; >08 00001000  joystick 2 down
     65C4 0002 
0135 65C6 1000             data  >1000,k2up            ; >10 00010000  joystick 2 up
     65C8 0004 
0136 65CA FFFF             data  >ffff
**** **** ****     > runlib.asm
1259               
1260               
1261               *//////////////////////////////////////////////////////////////
1262               *             Keyboard support (in real mode)
1263               *//////////////////////////////////////////////////////////////
1267               
1268               
1269               *//////////////////////////////////////////////////////////////
1270               *                            TIMERS
1271               *//////////////////////////////////////////////////////////////
1272               
1273               ***************************************************************
1274               * TMGR - X - Start Timer/Thread scheduler
1275               ***************************************************************
1276               *  B @TMGR
1277               *--------------------------------------------------------------
1278               *  REMARKS
1279               *  Timer/Thread scheduler. Normally called from MAIN.
1280               *  Don't forget to set BTIHI to highest slot in use.
1281               *
1282               *  Register usage in TMGR8 - TMGR11
1283               *  TMP0  = Pointer to timer table
1284               *  R10LB = Use as slot counter
1285               *  TMP2  = 2nd word of slot data
1286               *  TMP3  = Address of routine to call
1287               ********@*****@*********************@**************************
1288 65CC 0300  24 tmgr    limi  0                     ; No interrupt processing
     65CE 0000 
1289               *--------------------------------------------------------------
1290               * Read VDP status register
1291               *--------------------------------------------------------------
1292 65D0 D360  34 tmgr1   movb  @vdps,r13             ; Save copy of VDP status register in R13
     65D2 8802 
1293               *--------------------------------------------------------------
1294               * Latch sprite collision flag
1295               *--------------------------------------------------------------
1296 65D4 2360  38         coc   @wbit2,r13            ; C flag on ?
     65D6 601E 
1297 65D8 1602  14         jne   tmgr1a                ; No, so move on
1298 65DA E320  34         soc   @wbit12,config        ; Latch bit 12 in config register
     65DC 0012 
1299               *--------------------------------------------------------------
1300               * Interrupt flag
1301               *--------------------------------------------------------------
1302 65DE 2360  38 tmgr1a  coc   @wbit0,r13            ; Interupt flag set ?
     65E0 06A6 
1303 65E2 1316  14         jeq   tmgr4                 ; Yes, process slots 0..n
1304               *--------------------------------------------------------------
1305               * Run speech player
1306               *--------------------------------------------------------------
1307 65E4 2320  38         coc   @wbit3,config         ; Speech player on ?
     65E6 0036 
1308 65E8 1602  14         jne   tmgr2
1309 65EA 06A0  32         bl    @sppla1               ; Run speech player
     65EC 647A 
1310               *--------------------------------------------------------------
1311               * Run kernel thread
1312               *--------------------------------------------------------------
1313 65EE 2320  38 tmgr2   coc   @wbit8,config         ; Kernel thread blocked ?
     65F0 06B0 
1314 65F2 1305  14         jeq   tmgr3                 ; Yes, skip to user hook
1315 65F4 2320  38         coc   @wbit9,config         ; Kernel thread enabled ?
     65F6 101E 
1316 65F8 1602  14         jne   tmgr3                 ; No, skip to user hook
1317 65FA 0460  28         b     @kernel               ; Run kernel thread
     65FC 66A0 
1318               *--------------------------------------------------------------
1319               * Run user hook
1320               *--------------------------------------------------------------
1321 65FE 2320  38 tmgr3   coc   @wbit6,config         ; User hook blocked ?
     6600 0030 
1322 6602 13E6  14         jeq   tmgr1
1323 6604 2320  38         coc   @wbit7,config         ; User hook enabled ?
     6606 002A 
1324 6608 16E3  14         jne   tmgr1
1325 660A C120  34         mov   @wtiusr,tmp0
     660C 832E 
1326 660E 0454  20         b     *tmp0                 ; Run user hook
1327               *--------------------------------------------------------------
1328               * Do some internal housekeeping
1329               *--------------------------------------------------------------
1330 6610 4320  34 tmgr4   szc   @tmdat,config         ; Unblock kernel thread and user hook
     6612 6672 
1331 6614 C10A  18         mov   r10,tmp0
1332 6616 0244  22         andi  tmp0,>00ff            ; Clear HI byte
     6618 00FF 
1333 661A 2320  38         coc   @wbit2,config         ; PAL flag set ?
     661C 601E 
1334 661E 1303  14         jeq   tmgr5
1335 6620 0284  22         ci    tmp0,60               ; 1 second reached ?
     6622 003C 
1336 6624 1002  14         jmp   tmgr6
1337 6626 0284  22 tmgr5   ci    tmp0,50
     6628 0032 
1338 662A 1101  14 tmgr6   jlt   tmgr7                 ; No, continue
1339 662C 1001  14         jmp   tmgr8
1340 662E 058A  14 tmgr7   inc   r10                   ; Increase tick counter
1341               *--------------------------------------------------------------
1342               * Loop over slots
1343               *--------------------------------------------------------------
1344 6630 C120  34 tmgr8   mov   @wtitab,tmp0          ; Pointer to timer table
     6632 832C 
1345 6634 024A  22         andi  r10,>ff00             ; Use R10LB as slot counter. Reset.
     6636 FF00 
1346 6638 C1D4  26 tmgr9   mov   *tmp0,tmp3            ; Is slot empty ?
1347 663A 1316  14         jeq   tmgr11                ; Yes, get next slot
1348               *--------------------------------------------------------------
1349               *  Check if slot should be executed
1350               *--------------------------------------------------------------
1351 663C 05C4  14         inct  tmp0                  ; Second word of slot data
1352 663E 0594  26         inc   *tmp0                 ; Update tick count in slot
1353 6640 C194  26         mov   *tmp0,tmp2            ; Get second word of slot data
1354 6642 9820  54         cb    @tmp2hb,@tmp2lb       ; Slot target count = Slot internal counter ?
     6644 830C 
     6646 830D 
1355 6648 1608  14         jne   tmgr10                ; No, get next slot
1356 664A 0246  22         andi  tmp2,>ff00            ; Clear internal counter
     664C FF00 
1357 664E C506  30         mov   tmp2,*tmp0            ; Update timer table
1358               *--------------------------------------------------------------
1359               *  Run slot, we only need TMP0 to survive
1360               *--------------------------------------------------------------
1361 6650 C804  38         mov   tmp0,@wtitmp          ; Save TMP0
     6652 8330 
1362 6654 0697  24         bl    *tmp3                 ; Call routine in slot
1363 6656 C120  34 slotok  mov   @wtitmp,tmp0          ; Restore TMP0
     6658 8330 
1364               
1365               *--------------------------------------------------------------
1366               *  Prepare for next slot
1367               *--------------------------------------------------------------
1368 665A 058A  14 tmgr10  inc   r10                   ; Next slot
1369 665C 9820  54         cb    @r10lb,@btihi         ; Last slot done ?
     665E 8315 
     6660 8314 
1370 6662 1504  14         jgt   tmgr12                ; yes, Wait for next VDP interrupt
1371 6664 05C4  14         inct  tmp0                  ; Offset for next slot
1372 6666 10E8  14         jmp   tmgr9                 ; Process next slot
1373 6668 05C4  14 tmgr11  inct  tmp0                  ; Skip 2nd word of slot data
1374 666A 10F7  14         jmp   tmgr10                ; Process next slot
1375 666C 024A  22 tmgr12  andi  r10,>ff00             ; Use R10LB as tick counter. Reset.
     666E FF00 
1376 6670 10AF  14         jmp   tmgr1
1377 6672 0280     tmdat   data  >0280                 ; Bit 8 (kernel thread) and bit 6 (user hook)
1378               
1379               
1380               ***************************************************************
1381               * MKSLOT - Allocate timer slot(s)
1382               ***************************************************************
1383               *  BL    @MKSLOT
1384               *  BYTE  P0HB,P0LB
1385               *  DATA  P1
1386               *  ....
1387               *  DATA  EOL                        ; End-of-list
1388               *--------------------------------------------------------------
1389               *  P0 = Slot number, target count
1390               *  P1 = Subroutine to call via BL @xxxx if slot is fired
1391               ********@*****@*********************@**************************
1392 6674 C13B  30 mkslot  mov   *r11+,tmp0
1393 6676 C17B  30         mov   *r11+,tmp1
1394               *--------------------------------------------------------------
1395               *  Calculate address of slot
1396               *--------------------------------------------------------------
1397 6678 C184  18         mov   tmp0,tmp2
1398 667A 0966  56         srl   tmp2,6                ; Right align & TMP2 = TMP2 * 4
1399 667C A1A0  34         a     @wtitab,tmp2          ; Add table base
     667E 832C 
1400               *--------------------------------------------------------------
1401               *  Add slot to table
1402               *--------------------------------------------------------------
1403 6680 CD85  34         mov   tmp1,*tmp2+           ; Store address of subroutine
1404 6682 0A84  56         sla   tmp0,8                ; Get rid of slot number
1405 6684 C584  30         mov   tmp0,*tmp2            ; Store target count and reset tick count
1406               *--------------------------------------------------------------
1407               *  Check for end of list
1408               *--------------------------------------------------------------
1409 6686 881B  46         c     *r11,@whffff          ; End of list ?
     6688 0E2C 
1410 668A 1301  14         jeq   mkslo1                ; Yes, exit
1411 668C 10F3  14         jmp   mkslot                ; Process next entry
1412               *--------------------------------------------------------------
1413               *  Exit
1414               *--------------------------------------------------------------
1415 668E 05CB  14 mkslo1  inct  r11
1416 6690 045B  20         b     *r11                  ; Exit
1417               
1418               
1419               ***************************************************************
1420               * CLSLOT - Clear single timer slot
1421               ***************************************************************
1422               *  BL    @CLSLOT
1423               *  DATA  P0
1424               *--------------------------------------------------------------
1425               *  P0 = Slot number
1426               ********@*****@*********************@**************************
1427 6692 C13B  30 clslot  mov   *r11+,tmp0
1428 6694 0A24  56 xlslot  sla   tmp0,2                ; TMP0 = TMP0*4
1429 6696 A120  34         a     @wtitab,tmp0          ; Add table base
     6698 832C 
1430 669A 04F4  30         clr   *tmp0+                ; Clear 1st word of slot
1431 669C 04D4  26         clr   *tmp0                 ; Clear 2nd word of slot
1432 669E 045B  20         b     *r11                  ; Exit
1433               
1434               
1435               ***************************************************************
1436               * KERNEL - The kernel thread
1437               *--------------------------------------------------------------
1438               *  REMARKS
1439               *  You shouldn't call the kernel thread manually.
1440               *  Instead control it via the CONFIG register.
1441               ********@*****@*********************@**************************
1442 66A0 E320  34 kernel  soc   @wbit8,config         ; Block kernel thread
     66A2 06B0 
1443 66A4 2320  38         coc   @wbit13,config        ; Sound player on ?
     66A6 6022 
1444 66A8 1602  14         jne   kerne1
1445 66AA 06A0  32         bl    @sdpla1               ; Run sound player
     66AC 63C4 
1446 66AE 06A0  32 kerne1  bl    @virtkb               ; Scan virtual keyboard
     66B0 64DC 
1452 66B2 0460  28 kernez  b     @tmgr3                ; Exit
     66B4 65FE 
1453               
1454               
1455               
1456               ***************************************************************
1457               * MKHOOK - Allocate user hook
1458               ***************************************************************
1459               *  BL    @MKHOOK
1460               *  DATA  P0
1461               *--------------------------------------------------------------
1462               *  P0 = Address of user hook
1463               *--------------------------------------------------------------
1464               *  REMARKS
1465               *  The user hook gets executed after the kernel thread.
1466               *  The user hook must always exit with "B @HOOKOK"
1467               ********@*****@*********************@**************************
1468 66B6 C83B  50 mkhook  mov   *r11+,@wtiusr         ; Set user hook address
     66B8 832E 
1469 66BA 026C  22         ori   config,enusr          ; Enable user hook
     66BC 0100 
1470 66BE 045B  20 mkhoo1  b     *r11                  ; Return
1471      65D0     hookok  equ   tmgr1                 ; Exit point for user hook
1472               
1473               
1474               ***************************************************************
1475               * CLHOOK - Clear user hook
1476               ***************************************************************
1477               *  BL    @CLHOOK
1478               ********@*****@*********************@**************************
1479 66C0 04E0  34 clhook  clr   @wtiusr               ; Unset user hook address
     66C2 832E 
1480 66C4 024C  22         andi  config,>feff          ; Disable user hook (bit 7=0)
     66C6 FEFF 
1481 66C8 045B  20         b     *r11                  ; Return
1482               
1483               
1484               *//////////////////////////////////////////////////////////////
1485               *                       MISC FUNCTIONS
1486               *//////////////////////////////////////////////////////////////
1487               
1488               ***************************************************************
1489               * POPR. - Pop registers & return to caller
1490               ***************************************************************
1491               *  B  @POPRG.
1492               *--------------------------------------------------------------
1493               *  REMARKS
1494               *  R11 must be at stack bottom
1495               ********@*****@*********************@**************************
1496 66CA C0F9  30 popr3   mov   *stack+,r3
1497 66CC C0B9  30 popr2   mov   *stack+,r2
1498 66CE C079  30 popr1   mov   *stack+,r1
1499 66D0 C039  30 popr0   mov   *stack+,r0
1500 66D2 C2F9  30 poprt   mov   *stack+,r11
1501 66D4 045B  20         b     *r11
1502               
1503               *//////////////////////////////////////////////////////////////
1504               *                    RANDOM GENERATOR
1505               *//////////////////////////////////////////////////////////////
1509               
1510               
1511               *//////////////////////////////////////////////////////////////
1512               *                    RUNLIB INITIALISATION
1513               *//////////////////////////////////////////////////////////////
1514               
1515               ***************************************************************
1516               *  RUNLIB - Runtime library initalisation
1517               ***************************************************************
1518               *  B  @RUNLIB
1519               *--------------------------------------------------------------
1520               *  REMARKS
1521               *  If R1 in WS1 equals >FFFF we return to the TI title screen
1522               *  after clearing scratchpad memory.
1523               *  Use 'B @RUNLI1' to exit your program.
1524               ********@*****@*********************@**************************
1525 66D6 04E0  34 runlib  clr   @>8302                ; Reset exit flag (R1 in workspace WS1!)
     66D8 8302 
1526               *--------------------------------------------------------------
1527               * Alternative entry point
1528               *--------------------------------------------------------------
1529 66DA 0300  24 runli1  limi  0                     ; Turn off interrupts
     66DC 0000 
1530 66DE 02E0  18         lwpi  ws1                   ; Activate workspace 1
     66E0 8300 
1531 66E2 C0E0  34         mov   @>83c0,r3             ; Get random seed from OS monitor
     66E4 83C0 
1532               
1533               *--------------------------------------------------------------
1534               * Clear scratch-pad memory from R4 upwards
1535               *--------------------------------------------------------------
1536 66E6 0202  20 runli2  li    r2,>8308
     66E8 8308 
1537 66EA 04F2  30 runli3  clr   *r2+                  ; Clear scratchpad >8306->83FF
1538 66EC 0282  22         ci    r2,>8400
     66EE 8400 
1539 66F0 16FC  14         jne   runli3
1540               *--------------------------------------------------------------
1541               * Exit to TI-99/4A title screen ?
1542               *--------------------------------------------------------------
1543 66F2 0281  22         ci    r1,>ffff              ; Exit flag set ?
     66F4 FFFF 
1544 66F6 1602  14         jne   runli4                ; No, continue
1545 66F8 0420  54         blwp  @0                    ; Yes, bye bye
     66FA 0000 
1546               *--------------------------------------------------------------
1547               * Determine if VDP is PAL or NTSC
1548               *--------------------------------------------------------------
1549 66FC C803  38 runli4  mov   r3,@waux1             ; Store random seed
     66FE 833C 
1550 6700 04C1  14         clr   r1                    ; Reset counter
1551 6702 0202  20         li    r2,10                 ; We test 10 times
     6704 000A 
1552 6706 C0E0  34 runli5  mov   @vdps,r3
     6708 8802 
1553 670A 20E0  38         coc   @wbit0,r3             ; Interupt flag set ?
     670C 06A6 
1554 670E 1302  14         jeq   runli6
1555 6710 0581  14         inc   r1                    ; Increase counter
1556 6712 10F9  14         jmp   runli5
1557 6714 0602  14 runli6  dec   r2                    ; Next test
1558 6716 16F7  14         jne   runli5
1559 6718 0281  22         ci    r1,>1250              ; Max for NTSC reached ?
     671A 1250 
1560 671C 1202  14         jle   runli7                ; No, so it must be NTSC
1561 671E 026C  22         ori   config,palon          ; Yes, it must be PAL, set flag
     6720 2000 
1562               *--------------------------------------------------------------
1563               * Copy machine code to scratchpad (prepare tight loop)
1564               *--------------------------------------------------------------
1565 6722 0201  20 runli7  li    r1,mccode             ; Machinecode to patch
     6724 6030 
1566 6726 0202  20         li    r2,mcloop+2           ; Scratch-pad reserved for machine code
     6728 8322 
1567 672A CCB1  46         mov   *r1+,*r2+             ; Copy 1st instruction
1568 672C CCB1  46         mov   *r1+,*r2+             ; Copy 2nd instruction
1569 672E CCB1  46         mov   *r1+,*r2+             ; Copy 3rd instruction
1570               *--------------------------------------------------------------
1571               * Initialize registers, memory, ...
1572               *--------------------------------------------------------------
1573 6730 04C1  14 runli9  clr   r1
1574 6732 04C2  14         clr   r2
1575 6734 04C3  14         clr   r3
1576 6736 0209  20         li    stack,>8400           ; Set stack
     6738 8400 
1577 673A 020F  20         li    r15,vdpw              ; Set VDP write address
     673C 8C00 
1578 673E 06A0  32         bl    @mute                 ; Mute sound generators
     6740 6388 
1579               *--------------------------------------------------------------
1580               * Setup video memory
1581               *--------------------------------------------------------------
1582 6742 06A0  32         bl    @filv
     6744 605E 
1583 6746 0000             data  >0000,>00,16000       ; Clear VDP memory
     6748 0000 
     674A 3E80 
1584 674C 06A0  32         bl    @filv
     674E 605E 
1585 6750 0380             data  >0380,spfclr,16       ; Load color table
     6752 00F1 
     6754 0010 
1586               *--------------------------------------------------------------
1587               * Check if there is a F18A present
1588               *--------------------------------------------------------------
1594               *--------------------------------------------------------------
1595               * Check if there is a speech synthesizer attached
1596               *--------------------------------------------------------------
1600               *--------------------------------------------------------------
1601               * Load video mode table & font
1602               *--------------------------------------------------------------
1603 6756 06A0  32 runlic  bl    @vidtab               ; Load video mode table into VDP
     6758 6122 
1604 675A 6026             data  spvmod                ; Equate selected video mode table
1605 675C 0204  20         li    tmp0,spfont           ; Get font option
     675E 800C 
1606 6760 0544  14         inv   tmp0                  ; NOFONT (>FFFF) specified ?
1607 6762 1304  14         jeq   runlid                ; Yes, skip it
1608 6764 06A0  32         bl    @ldfnt
     6766 61FA 
1609 6768 0900             data  >0900,spfont          ; Load specified font
     676A 800C 
1610               *--------------------------------------------------------------
1611               * Branch to main program
1612               *--------------------------------------------------------------
1613 676C 026C  22 runlid  ori   config,enknl          ; Enable kernel thread
     676E 0040 
1614 6770 0460  28         b     @main                 ; Give control to main program
     6772 677C 
**** **** ****     > 7thpong_cart.asm
0064               *--------------------------------------------------------------
0065               * SPECTRA2 startup options
0066               *--------------------------------------------------------------
0067      00F1     spfclr  equ   >f1                   ; Foreground/Background color for font.
0068      0001     spfbck  equ   >01                   ; Screen background color.
0069               *--------------------------------------------------------------
0070               * Variables
0071               *--------------------------------------------------------------
0072      8342     highsc  equ   >8342                 ; High-Score
0073      8344     counter equ   >8344                 ; Delay counter for restart thread
0074      8346     hintpos equ   >8346                 ; YX Position of hint to erase
0075      8348     delay   equ   >8348                 ; Initial value for delay counter
0076      834A     balmovy equ   >834a                 ; Vertical movement of ball
0077               ; free  equ   >834c                 ; 2 bytes free
0078      834E     baldir  equ   >834e                 ; Ball direction
0079      8350     tmpvar  equ   >8350                 ; Used by blink thread
0080      8352     colors  equ   >8352                 ; Used by rainbow thread
0081      8354     score1  equ   >8354                 ; Player 1 score
0082      8356     score2  equ   >8356                 ; Player 2 score
0083      8358     ramsat  equ   >8358                 ; SAT in RAM for 4 sprites (16 bytes)
0084      8368     rambuf  equ   >8368                 ; Work buffer
0085      83E0     timers  equ   >83e0                 ; Timer table (16 bytes/4 slots)
0086      83FC     message equ   >83fc                 ; Address of blinking message
0087      83FE     random  equ   >83fe                 ; Address of random table
0088               ;--------------------------------------------------------------
0089               ; graphics mode 1 configuration (32x24)
0090               ;--------------------------------------------------------------
0091      6026     spvmod  equ   graph1                ; Video mode.   See VIDTAB for details.
0092      800C     spfont  equ   fnopt7                ; Font to load. See LDFONT for details.
0093               ***************************************************************
0094               * Main
0095               ********@*****@*********************@**************************
0096               cold_boot
0097 6774 04E0  34         clr   @>8300                ; Clear R0 (where spectra2 ws will be),
     6776 8300 
0098 6778 0460  28         b     @runlib               ; we use this to reset the high-score
     677A 66D6 
0099 677C C800  38 main    mov   r0,@highsc            ; Save high-score (r0 survives spectra reset)
     677E 8342 
0100 6780 05E0  34         inct  @colors               ; Initial setup of colors
     6782 8352 
0101 6784 06A0  32         bl    @vputb
     6786 6102 
0102 6788 0300             data  >0300,>d0d0           ; Reset SAT
     678A D0D0 
0103               *--------------------------------------------------------------
0104               * Setup characters
0105               *--------------------------------------------------------------
0106 678C 06A0  32         bl    @rle2v                ; Characters 1-15
     678E 60AA 
0107 6790 6CA2             data  rle_chars,>0808,84    ; Pattern table VDP >0800
     6792 0808 
     6794 0054 
0108               *--------------------------------------------------------------
0109               * High-Score
0110               *--------------------------------------------------------------
0111 6796 06A0  32         bl    @putat
     6798 62A6 
0112 679A 000B             data  >000b,high
     679C 6CF8 
0113 679E 06A0  32         bl    @putnum               ; High-Score
     67A0 637E 
0114 67A2 000E             data  >000e,highsc,rambuf,>3030
     67A4 8342 
     67A6 8368 
     67A8 3030 
0115               *--------------------------------------------------------------
0116               * Title "7th Pong"
0117               *--------------------------------------------------------------
0118 67AA 06A0  32         bl    @rle2v                ; RLE Decompress to VRAM
     67AC 60AA 
0119 67AE 6B92             data  rle_title,>0020,272
     67B0 0020 
     67B2 0110 
0120               *---------------------------------------------------------------
0121               * Credits
0122               *---------------------------------------------------------------
0123 67B4 06A0  32         bl    @putat
     67B6 62A6 
0124 67B8 0F08             data  >0f08,sweet         ; Short'n'Sweet
     67BA 6CFC 
0125 67BC 06A0  32         bl    @putat
     67BE 62A6 
0126 67C0 1707             data  >1707,credit        ; (c) Retroclouds Team
     67C2 6D20 
0127               *--------------------------------------------------------------
0128               * Setup threads for title screen
0129               *--------------------------------------------------------------
0130 67C4 0200  20         li    r0,play             ; "Press Fire To Play"
     67C6 6D0D 
0131 67C8 C800  38         mov   r0,@message         ; Blinking message
     67CA 83FC 
0132 67CC 0200  20         li    r0,timers
     67CE 83E0 
0133 67D0 C800  38         mov   r0,@wtitab          ; Our timer table
     67D2 832C 
0134 67D4 06A0  32         bl    @mkslot
     67D6 6674 
0135 67D8 0040             data  >0040,one_time_delay_music
     67DA 68A8 
0136                                                 ; Toggle play message every 10 ticks
0137 67DC 0101             data  >0101,rainbow,eol   ; Swap colors every 1 tick(s)
     67DE 68E4 
     67E0 FFFF 
0138 67E2 D820  54         movb  @bd1,@tmpvar+1      ; Set toggle
     67E4 002A 
     67E6 8351 
0139 67E8 D820  54         movb  @bd1,@btihi         ; Set highest slot in use
     67EA 002A 
     67EC 8314 
0140 67EE 06A0  32         bl    @mkhook
     67F0 66B6 
0141 67F2 67FE             data  start               ; Enable User Hook
0142               *--------------------------------------------------------------
0143               * Speech stuff
0144               *--------------------------------------------------------------
0145 67F4 06A0  32         bl    @spprep             ; Run speech synthesizer
     67F6 646A 
0146 67F8 6D64             data  can_you_make_it
0147 67FA 0460  28 main1   b     @tmgr               ; Run scheduler
     67FC 65CC 
0148               *--------------------------------------------------------------
0149               * User Hook for starting new game
0150               *--------------------------------------------------------------
0151 67FE 2320  38 start   coc   @wbit11,config      ; ANY key pressed ?
     6800 6020 
0152 6802 1605  14         jne   start2
0153 6804 2320  38         coc   @wbit3,config       ; Speech synthesizer busy?
     6806 0036 
0154 6808 1302  14         jeq   start2              ; Yes, ignore key & wait until speech done
0155 680A 0460  28         b     @setup              ; Setup game
     680C 6812 
0156 680E 0460  28 start2  b     @hookok             ; Exit hook
     6810 65D0 
0157               
0158               
0159               
0160               *--------------------------------------------------------------
0161               * Setup game
0162               *--------------------------------------------------------------
0163               setup
0164 6812 06A0  32         bl    @filv
     6814 605E 
0165 6816 0000             data  >0000,>20,768       ; Clear screen
     6818 0020 
     681A 0300 
0166 681C 06A0  32         bl    @vchar
     681E 62D6 
0167 6820 000F             byte  >00,>0f,08,24       ; Draw vertical bar
     6822 0818 
0168 6824 FFFF             data  eol
0169               *---------------------------------------------------------------
0170               * Init variables
0171               *---------------------------------------------------------------
0172 6826 0200  20         li    r0,500              ; Initial score 500 points
     6828 01F4 
0173 682A C800  38         mov   r0,@score1          ; Player 1
     682C 8354 
0174 682E C800  38         mov   r0,@score2          ; Player 2
     6830 8356 
0175 6832 0200  20         li    r0,900
     6834 0384 
0176 6836 C800  38         mov   r0,@delay           ; Set initial value for delay counter
     6838 8348 
0177 683A 0200  20         li    r0,>00ff            ; Ball direction YX. >ff = -1
     683C 00FF 
0178 683E C800  38         mov   r0,@baldir
     6840 834E 
0179 6842 0580  14         inc   r0
0180 6844 C800  38         mov   r0,@balmovy
     6846 834A 
0181 6848 04E0  34         clr   @random             ; Use system ROM as random table
     684A 83FE 
0182 684C 04E0  34         clr   @hintpos            ; Reset scoring position + sprite collision!
     684E 8346 
0183               
0184 6850 06A0  32         bl    @s8x8               ; 8x8 sprite pattern
     6852 6196 
0185 6854 06A0  32         bl    @smag2x             ; 2x Sprite magnification
     6856 6190 
0186               *---------------------------------------------------------------
0187               * Inline memory copy (cpym2m), saving some code size
0188               *---------------------------------------------------------------
0189 6858 0200  20         li    r0,>dd74            ; MOVB *TMP0+,*TMP1+
     685A DD74 
0190 685C C800  38         mov   r0,@mcloop          ; Setup copy operation
     685E 8320 
0191 6860 0204  20         li    tmp0,romsat
     6862 6D56 
0192 6864 0205  20         li    tmp1,ramsat
     6866 8358 
0193 6868 0206  20         li    tmp2,14
     686A 000E 
0194 686C 06A0  32         bl    @mcloop             ; Copy SAT from ROM to RAM
     686E 8320 
0195               *---------------------------------------------------------------
0196               * Copy patterns and setup threads
0197               *---------------------------------------------------------------
0198 6870 06A0  32         bl    @rle2v              ; Copy sprite patterns to SDT
     6872 60AA 
0199 6874 6CF6             data  rle_sprite_patterns,>1000,2
     6876 1000 
     6878 0002 
0200 687A 06A0  32         bl    @mkslot             ; Run game controller every tick
     687C 6674 
0201 687E 0001             data  >0001,game_controller
     6880 692A 
0202 6882 0102             data  >0102,rainbow       ; Swap colors every 2 ticks
     6884 68E4 
0203 6886 0230             data  >0230,clear_hint    ; Clear last hint every 2 seconds
     6888 6916 
0204 688A 0305             data  >0305,move_ball_Y   ; Move the ball diagonally
     688C 69DC 
0205 688E FFFF             data  eol
0206 6890 020A  20         li    r10,>0300           ; Set highest slot to 3
     6892 0300 
0207 6894 06A0  32         bl    @mkhook
     6896 66B6 
0208 6898 69EC             data  player              ; Setup user hook
0209 689A 04CD  14         clr   r13                 ; Reset copy of VDP status register!
0210 689C 06A0  32         bl    @sdprep
     689E 63A6 
0211 68A0 6EF0             data  title_screen_music,sdopt1
     68A2 0007 
0212 68A4 0460  28         b     @tmgr               ; Start scheduler
     68A6 65CC 
0213               *--------------------------------------------------------------
0214               * End main
0215               *--------------------------------------------------------------
0216               
0217               
0218               ***************************************************************
0219               * Threads and Hooks
0220               ***************************************************************
0221               
0222               
0223               ***************************************************************
0224               * Thread: One time delay for starting music
0225               ********@*****@*******************@****************************
0226               one_time_delay_music:
0227 68A8 06A0  32         bl    @sdprep
     68AA 63A6 
0228 68AC 6EF0             data  title_screen_music,sdopt1
     68AE 0007 
0229 68B0 06A0  32         bl    @mkslot
     68B2 6674 
0230 68B4 0009             data  >0009,blink,eol     ; Blinking message
     68B6 68BE 
     68B8 FFFF 
0231 68BA 0460  28         b     @slotok
     68BC 6656 
0232               
0233               
0234               ***************************************************************
0235               * Thread: Blinking message
0236               ********@*****@*******************@****************************
0237 68BE 0520  36 blink   neg   @tmpvar             ; Switch toggle
     68C0 8350 
0238 68C2 1109  14         jlt   blink2
0239 68C4 0205  20 blink1  li    tmp1,>1307          ; Y=19, X=7
     68C6 1307 
0240 68C8 C805  38         mov   tmp1,@wyx
     68CA 832A 
0241 68CC C160  34         mov   @message,tmp1       ; Address of text to display
     68CE 83FC 
0242 68D0 06A0  32         bl    @xutst0             ; Display message
     68D2 6296 
0243 68D4 1005  14         jmp   blink3
0244 68D6 06A0  32 blink2  bl    @hchar
     68D8 62AE 
0245 68DA 1300             byte  >13,>00,32,32       ; white space x
     68DC 2020 
0246 68DE FFFF             data  eol
0247 68E0 0460  28 blink3  b     @slotok             ; Exit to Thread Scheduler
     68E2 6656 
0248               
0249               
0250               ***************************************************************
0251               * Thread: Rainbow colors
0252               ********@*****@*******************@****************************
0253 68E4 C160  34 rainbow mov   @colors,tmp1
     68E6 8352 
0254 68E8 0585  14         inc   tmp1
0255 68EA 0285  22         ci    tmp1,>0f
     68EC 000F 
0256 68EE 1202  14         jle   rainbow_rest
0257 68F0 0205  20         li    tmp1,>02
     68F2 0002 
0258               
0259               rainbow_rest:
0260 68F4 C805  38         mov   tmp1,@colors
     68F6 8352 
0261 68F8 0206  20         li    tmp2,>10
     68FA 0010 
0262 68FC 6185  18         s     tmp1,tmp2
0263 68FE 06C6  14         swpb  tmp2
0264 6900 D806  38         movb  tmp2,@ramsat+11     ; Set sprite color
     6902 8363 
0265 6904 0A45  56         sla   tmp1,4              ; Change Tiles foreground color
0266 6906 0204  20         li    tmp0,>0380          ; Color table is at VDP>0380
     6908 0380 
0267 690A 0206  20         li    tmp2,2
     690C 0002 
0268 690E 06A0  32         bl    @xfilv
     6910 6064 
0269 6912 0460  28         b     @slotok             ; Exit to Thread Scheduler
     6914 6656 
0270               
0271               
0272               ***************************************************************
0273               * Thread: Clear hints
0274               ********@*****@*******************@****************************
0275               clear_hint:
0276 6916 C820  54         mov   @hintpos,@WYX
     6918 8346 
     691A 832A 
0277 691C 06A0  32         bl    @putstr
     691E 6294 
0278 6920 6D50             data  erase_hint          ; Show empty string
0279 6922 04E0  34         clr   @hintpos            ; Enable sprite collision (hack!)
     6924 8346 
0280 6926 0460  28         b     @slotok
     6928 6656 
0281               
0282               ***************************************************************
0283               * Thread: Game controller
0284               ********@*****@*******************@****************************
0285               game_controller:
0286 692A C020  34         mov   @score1,r0
     692C 8354 
0287 692E 1501  14         jgt   check_score_p2       ; score P1 > 0, move on
0288 6930 100D  14         jmp   game_over_p1         ; Game Over P1
0289               check_score_p2:
0290 6932 C020  34         mov   @score2,r0
     6934 8356 
0291 6936 1501  14         jgt   continue             ; Score P2 > 0, move on
0292 6938 1013  14         jmp   game_over_p2         ; Game Over P2
0293               continue:
0294 693A 06A0  32         bl    @display_scores      ; Show scores
     693C 69AE 
0295 693E 06A0  32         bl    @cpym2v
     6940 6084 
0296 6942 0300             data  >0300,ramsat,16      ; Copy shadow SAT to VDP
     6944 8358 
     6946 0010 
0297 6948 0460  28         b     @slotok
     694A 6656 
0298               *--------------------------------------------------------------
0299               * Game over - player 1 has lost
0300               *--------------------------------------------------------------
0301               game_over_p1:
0302 694C 04E0  34         clr   @score1              ; P1 score = 00000
     694E 8354 
0303 6950 C060  34         mov   @score2,r1
     6952 8356 
0304 6954 8801  38         c     r1,@highsc           ; P2 score > HI score ?
     6956 8342 
0305 6958 110C  14         jlt   game_over_rest
0306 695A C801  38         mov   r1,@highsc           ; New HI score
     695C 8342 
0307 695E 1009  14         jmp   game_over_rest
0308               *--------------------------------------------------------------
0309               * Game over - player 2 has lost
0310               *--------------------------------------------------------------
0311               game_over_p2:
0312 6960 04E0  34         clr   @score2              ; P2 score = 00000
     6962 8356 
0313 6964 C060  34         mov   @score1,r1
     6966 8354 
0314 6968 8801  38         c     r1,@highsc           ; P1 score > HI score ?
     696A 8342 
0315 696C 1102  14         jlt   game_over_rest
0316 696E C801  38         mov   r1,@highsc           ; New HI score
     6970 8342 
0317               *--------------------------------------------------------------
0318               * Game Over - Rest
0319               *--------------------------------------------------------------
0320               game_over_rest:
0321 6972 06A0  32         bl    @mute
     6974 6388 
0322 6976 06A0  32         bl    @spprep              ; Run speech synthesizer
     6978 646A 
0323 697A 6E40             data  hahaha
0324 697C 06A0  32         bl    @display_scores
     697E 69AE 
0325 6980 0200  20         li    r0,msg_game_over     ; Game over!
     6982 6D33 
0326 6984 C800  38         mov   r0,@message          ; Set game over message
     6986 83FC 
0327 6988 06A0  32         bl    @mkslot
     698A 6674 
0328 698C 000A             data  >000a,blink          ; Toggle blinking message
     698E 68BE 
0329 6990 0103             data  >0103,rainbow
     6992 68E4 
0330 6994 0260             data  >0260,restart,eol
     6996 69CA 
     6998 FFFF 
0331 699A 020A  20         li    r10,>0200            ; Set highest slot to 2
     699C 0200 
0332 699E 06A0  32         bl    @clhook              ; Clear user hook
     69A0 66C0 
0333               
0334 69A2 0200  20         li    r0,4
     69A4 0004 
0335 69A6 C800  38         mov   r0,@counter          ; Set thread delay counter
     69A8 8344 
0336 69AA 0460  28         b     @slotok              ; Exit thread
     69AC 6656 
0337               *--------------------------------------------------------------
0338               * Subroutine: Display scores
0339               *--------------------------------------------------------------
0340               display_scores:
0341 69AE C04B  18         mov   r11,r1               ; Save return address
0342 69B0 06A0  32         bl    @putnum              ; Display score player 1
     69B2 637E 
0343 69B4 0004             data  >0004,score1,rambuf,>3030
     69B6 8354 
     69B8 8368 
     69BA 3030 
0344 69BC 06A0  32         bl    @putnum              ; Display score player 2
     69BE 637E 
0345 69C0 0016             data  >0016,score2,rambuf,>3030
     69C2 8356 
     69C4 8368 
     69C6 3030 
0346 69C8 0451  20         b     *r1                  ; Return
0347               *--------------------------------------------------------------
0348               * End Thread
0349               *--------------------------------------------------------------
0350               
0351               
0352               ***************************************************************
0353               * Thread: Game over - Back to title screen
0354               ********@*****@*******************@****************************
0355               restart:
0356 69CA 0620  34         dec   @counter            ; Decrease delay counter
     69CC 8344 
0357 69CE 1302  14         jeq   back_to_title
0358 69D0 0460  28         b     @slotok             ; Exit thread
     69D2 6656 
0359               back_to_title:
0360 69D4 C020  34         mov   @highsc,r0
     69D6 8342 
0361 69D8 0460  28         b     @runlib             ; Reset game (but keep high score)
     69DA 66D6 
0362               *--------------------------------------------------------------
0363               * End Thread
0364               *--------------------------------------------------------------
0365               
0366               
0367               
0368               ***************************************************************
0369               * Thread: Move ball vertically
0370               ********@*****@*******************@****************************
0371               move_ball_y:
0372 69DC C020  34         mov   @ramsat+8,r0
     69DE 8360 
0373 69E0 A020  34         a     @balmovy,r0
     69E2 834A 
0374 69E4 C800  38         mov   r0,@ramsat+8
     69E6 8360 
0375 69E8 0460  28         b     @slotok
     69EA 6656 
0376               *--------------------------------------------------------------
0377               * End Thread
0378               *--------------------------------------------------------------
0379               
0380               
0381               
0382               ***************************************************************
0383               * Hook: Sprite controll
0384               ********@*****@*******************@****************************
0385 69EC 2320  38 player  coc   @wbit11,config      ; Any key pressed ?
     69EE 6020 
0386 69F0 1620  14         jne   move_ball           ; No, so skip key processing
0387 69F2 C060  34         mov   @wvrtkb,r1          ; For easy processing
     69F4 8332 
0388               *--------------------------------------------------------------
0389               * Paddle player one
0390               *--------------------------------------------------------------
0391 69F6 0202  20 playl   li    r2,k1up
     69F8 0080 
0392 69FA 2042  18         coc   r2,r1               ; Up?
0393 69FC 1604  14         jne   play1a
0394 69FE 7820  54         sb    @bd1,@ramsat        ; Y=Y-1
     6A00 002A 
     6A02 8358 
0395 6A04 1007  14         jmp   play2
0396 6A06 0202  20 play1a  li    r2,k1dn
     6A08 0040 
0397 6A0A 2042  18         coc   r2,r1               ; Down?
0398 6A0C 1603  14         jne   play2
0399 6A0E B820  54         ab    @bd1,@ramsat        ; Y=Y+1
     6A10 002A 
     6A12 8358 
0400               *--------------------------------------------------------------
0401               * Paddle player two
0402               *--------------------------------------------------------------
0403 6A14 0202  20 play2   li    r2,k2up
     6A16 0004 
0404 6A18 2042  18         coc   r2,r1               ; Up
0405 6A1A 1604  14         jne   play2a
0406 6A1C 7820  54         sb    @bd1,@ramsat+4      ; Y=Y-1
     6A1E 002A 
     6A20 835C 
0407 6A22 1007  14         jmp   move_ball
0408 6A24 0202  20 play2a  li    r2,k2dn
     6A26 0002 
0409 6A28 2042  18         coc   r2,r1               ; Down?
0410 6A2A 1603  14         jne   move_ball
0411 6A2C B820  54         ab    @bd1,@ramsat+4      ; Y=Y+1
     6A2E 002A 
     6A30 835C 
0412               *--------------------------------------------------------------
0413               * Move ball
0414               *--------------------------------------------------------------
0415               move_ball:
0416 6A32 2320  38         coc   @wbit12,config      ; Sprite collision occured?
     6A34 0012 
0417 6A36 1646  14         jne   is_ball_out         ; No, check if ball is out
0418               *--------------------------------------------------------------
0419               * Ball must bounce
0420               *--------------------------------------------------------------
0421               move_ball_check_up:               ; Don't lose ball at top of screen
0422 6A38 C020  34         mov   @ramsat+8,r0        ; Get Y
     6A3A 8360 
0423 6A3C 0980  56         srl   r0,8                ; Remove X
0424 6A3E 0280  22         ci    r0,50               ; Y < 50 ?
     6A40 0032 
0425 6A42 1505  14         jgt   move_ball_check_down
0426 6A44 0200  20         li    r0,>0100
     6A46 0100 
0427 6A48 C800  38         mov   r0,@balmovy         ; Set Y direction to +1
     6A4A 834A 
0428 6A4C 1007  14         jmp   move_ball_continue
0429               *--------------------------------------------------------------
0430               move_ball_check_down:             ; Don't lose ball at screen bottom
0431 6A4E 0280  22         ci    r0,145              ; Y > 145 ?
     6A50 0091 
0432 6A52 1104  14         jlt   move_ball_continue
0433 6A54 0200  20         li    r0,>ff00
     6A56 FF00 
0434 6A58 C800  38         mov   r0,@balmovy         ; Set Y direction to -1
     6A5A 834A 
0435               *--------------------------------------------------------------
0436               move_ball_continue:
0437 6A5C 4320  34         szc   @wbit12,config      ; Unlatch collision flag in config register
     6A5E 0012 
0438 6A60 E320  34         soc   @wbit6,config       ; Block user hook until next frame! (delay)
     6A62 0030 
0439 6A64 C020  34         mov   @hintpos,r0         ; Should we process collision ?
     6A66 8346 
0440 6A68 1302  14         jeq   move_ball_collision ; Yes
0441 6A6A 0460  28         b     @move_ball_x        ; No, must be a "ghost"
     6A6C 6B7E 
0442               move_ball_collision:
0443 6A6E C020  34         mov   @baldir,r0
     6A70 834E 
0444 6A72 0280  22         ci    r0,>00ff            ; Moving ball to the left?
     6A74 00FF 
0445 6A76 1613  14         jne   bounce_left         ; No, was moving right, now bounce left
0446               *--------------------------------------------------------------
0447               * Ball - Bounce from left to right
0448               *--------------------------------------------------------------
0449               bounce_right:
0450 6A78 0200  20         li    r0,>0001            ; Move ball right
     6A7A 0001 
0451 6A7C C800  38         mov   r0,@baldir
     6A7E 834E 
0452 6A80 0200  20         li    r0,>0a00            ; Set new start position X >0a
     6A82 0A00 
0453 6A84 D800  38         movb  r0,@ramsat+9        ; New position
     6A86 8361 
0454 6A88 0200  20         li    r0,25               ; Player 1 score +25
     6A8A 0019 
0455 6A8C 0201  20         li    r1,bonus25
     6A8E 6D46 
0456 6A90 0202  20         li    r2,move_ball_x
     6A92 6B7E 
0457 6A94 6800  38         S     r0,@delay           ; Speedup game
     6A96 8348 
0458 6A98 026C  22         ori   config,>0040        ; Turn on bit 6 - Block user hook
     6A9A 0040 
0459 6A9C 1030  14         jmp   hint_player1
0460               *--------------------------------------------------------------
0461               * Ball - Bounce from right to left
0462               *--------------------------------------------------------------
0463               bounce_left:
0464 6A9E 0200  20         li    r0,>00ff            ; Move ball left
     6AA0 00FF 
0465 6AA2 C800  38         mov   r0,@baldir
     6AA4 834E 
0466 6AA6 0200  20         li    r0,>ea00            ; Set new start position
     6AA8 EA00 
0467 6AAA D800  38         movb  r0,@ramsat+9        ; New position
     6AAC 8361 
0468 6AAE 0200  20         li    r0,25               ; Player 2 score +25
     6AB0 0019 
0469 6AB2 0201  20         li    r1,bonus25
     6AB4 6D46 
0470 6AB6 0202  20         li    r2,move_ball_x
     6AB8 6B7E 
0471 6ABA 6800  38         S     r0,@delay           ; Speedup game
     6ABC 8348 
0472 6ABE 026C  22         ori   config,>0040        ; Turn on bit 6
     6AC0 0040 
0473 6AC2 1037  14         jmp   hint_player2
0474               *--------------------------------------------------------------
0475               * Check if ball is out
0476               *--------------------------------------------------------------
0477               is_ball_out:
0478 6AC4 C020  34         mov   @baldir,r0
     6AC6 834E 
0479 6AC8 C060  34         mov   @ramsat+8,r1
     6ACA 8360 
0480 6ACC 0241  22         andi  r1,>00ff            ; Remove Y position
     6ACE 00FF 
0481               *--------------------------------------------------------------
0482               * Ball out on left screen side ?
0483               *--------------------------------------------------------------
0484 6AD0 0280  22 balout1 ci    r0,>00ff            ; Moving bal to the left?
     6AD2 00FF 
0485 6AD4 160A  14         jne   balout2             ; No, moving right
0486 6AD6 0281  22         ci    r1,>0005            ; Check if bal X < 0x5
     6AD8 0005 
0487 6ADA 1551  14         jgt   move_ball_x         ; No, so just move ball
0488               *--------------------------------------------------------------
0489               *  Ball out - left
0490               *--------------------------------------------------------------
0491 6ADC 0200  20         li    r0,-100             ; Player 1 score -100
     6ADE FF9C 
0492 6AE0 0201  20         li    r1,lost100
     6AE2 6D4B 
0493 6AE4 0202  20         li    r2,new_ball_left    ; New ball on left side
     6AE6 6B20 
0494 6AE8 100A  14         jmp   hint_player1        ; Display score hint
0495               *--------------------------------------------------------------
0496               * Ball out on right screen side ?
0497               *--------------------------------------------------------------
0498 6AEA 0281  22 balout2 ci    r1,>00f5            ; Check if bal X > 0xf5
     6AEC 00F5 
0499 6AEE 1147  14         jlt   move_ball_x         ; No, so just move ball
0500               *--------------------------------------------------------------
0501               * Ball out - right
0502               *--------------------------------------------------------------
0503 6AF0 0200  20         li    r0,-100             ; Player 2 score -100
     6AF2 FF9C 
0504 6AF4 0201  20         li    r1,lost100
     6AF6 6D4B 
0505 6AF8 0202  20         li    r2,new_ball_right   ; New ball on right side
     6AFA 6B58 
0506 6AFC 101A  14         jmp   hint_player2        ; Display score hint
0507               *--------------------------------------------------------------
0508               * Show score adjustment player 1
0509               *--------------------------------------------------------------
0510               * R0=Score to add/subtract
0511               * R1=Text to display
0512               * R2=Return address
0513               *--------------------------------------------------------------
0514               hint_player1:
0515 6AFE A800  38         a     r0,@score1          ; Adjust player 1 score
     6B00 8354 
0516 6B02 C120  34         mov   @ramsat+8,tmp0
     6B04 8360 
0517 6B06 06A0  32         bl    @px2yx
     6B08 61C6 
0518 6B0A C804  38         mov   tmp0,@wyx           ; Set current YX position
     6B0C 832A 
0519 6B0E C804  38         mov   tmp0,@hintpos       ; For erasing later on
     6B10 8346 
0520 6B12 C141  18         mov   r1,tmp1
0521 6B14 06A0  32         bl    @xutst0
     6B16 6296 
0522 6B18 C820  54         mov   @x3000,@timers+10   ; Reset slot 2 thread
     6B1A 6B90 
     6B1C 83EA 
0523 6B1E 0452  20         b     *R2                 ; Branch to next routine
0524               *--------------------------------------------------------------
0525               * New ball on left side, moving right
0526               *--------------------------------------------------------------
0527               new_ball_left:
0528 6B20 0200  20         li    r0,>0001            ; Move ball right
     6B22 0001 
0529 6B24 C800  38         mov   r0,@baldir
     6B26 834E 
0530 6B28 0200  20         li    r0,>002f            ; New start position
     6B2A 002F 
0531 6B2C C800  38         mov   r0,@ramsat+8        ; Update X position
     6B2E 8360 
0532 6B30 101B  14         jmp   new_random_y        ; Random Y position
0533               *--------------------------------------------------------------
0534               * Show score adjustment player 2
0535               *--------------------------------------------------------------
0536               * R0=Score to add/subtract
0537               * R1=Text to display
0538               * R2=Return address
0539               *--------------------------------------------------------------
0540               hint_player2:
0541 6B32 A800  38         a     r0,@score2          ; Adjust player 2 score
     6B34 8356 
0542 6B36 C120  34         mov   @ramsat+8,tmp0
     6B38 8360 
0543 6B3A 06A0  32         bl    @px2yx
     6B3C 61C6 
0544 6B3E 0224  22         ai    tmp0,>fffe          ; Y-1, X-1
     6B40 FFFE 
0545 6B42 C804  38         mov   tmp0,@wyx           ; Set current YX position
     6B44 832A 
0546 6B46 C804  38         mov   tmp0,@hintpos       ; For erasing later on
     6B48 8346 
0547 6B4A C141  18         mov   r1,tmp1
0548 6B4C 06A0  32         bl    @xutst0
     6B4E 6296 
0549 6B50 C820  54         mov   @x3000,@timers+10   ; Reset slot 2 thread
     6B52 6B90 
     6B54 83EA 
0550 6B56 0452  20         b     *R2                 ; Branch to next routine
0551               *--------------------------------------------------------------
0552               * New ball on right side, moving left
0553               *--------------------------------------------------------------
0554               new_ball_right:
0555 6B58 0200  20         li    r0,>00ff            ; Move ball left
     6B5A 00FF 
0556 6B5C C800  38         mov   r0,@baldir
     6B5E 834E 
0557 6B60 0200  20         li    r0,>00a0            ; New start position
     6B62 00A0 
0558 6B64 C800  38         mov   r0,@ramsat+8        ; Update X position
     6B66 8360 
0559               *--------------------------------------------------------------
0560               * Get random Y position for new ball
0561               *--------------------------------------------------------------
0562               new_random_y:
0563 6B68 C020  34         mov   @random,r0          ; Get address of random
     6B6A 83FE 
0564 6B6C D010  26         movb  *r0,r0              ; Get random byte
0565 6B6E 05A0  34         inc   @random             ; Next byte in random table
     6B70 83FE 
0566 6B72 0240  22         andi  r0,>a000            ; Make sure Y is <= a0
     6B74 A000 
0567 6B76 0220  22         ai    r0,>1000            ; Minimum Y=1
     6B78 1000 
0568 6B7A D800  38         movb  r0,@ramsat+8        ; Update Y position
     6B7C 8360 
0569               *--------------------------------------------------------------
0570               * Get new X position for ball
0571               *--------------------------------------------------------------
0572               move_ball_x:
0573 6B7E B820  54         ab    @baldir+1,@ramsat+9 ; Move ball
     6B80 834F 
     6B82 8361 
0574               *--------------------------------------------------------------
0575               * Exit hook
0576               *--------------------------------------------------------------
0577 6B84 C0A0  34 playex  mov   @delay,r2           ; Load delay value
     6B86 8348 
0578 6B88 0602  14 dodelay dec   r2
0579 6B8A 16FE  14         jne   dodelay
0580 6B8C 0460  28         b     @hookok
     6B8E 65D0 
0581               *--------------------------------------------------------------
0582               * End Thread
0583               *--------------------------------------------------------------
0584               
0585               
0586               ***************************************************************
0587               * Data
0588               ***************************************************************
0589 6B90 1800     x3000   data  >1800                   ; Delay value for timer 2
0590               
0591               *--------------------------------------------------------------
0592               * Data - RLE Compressed title "7th Pong"
0593               *--------------------------------------------------------------
0594               * Compressed 272 bytes / Uncompressed 384 bytes / 70.8% size
0595               rle_title:
0596 6B92 8400             byte  >84,>00,>89,>07,>82,>00
     6B94 8907 
     6B96 8200 
0597 6B98 8207             byte  >82,>07,>81,>03,>82,>00
     6B9A 8103 
     6B9C 8200 
0598 6B9E 8207             byte  >82,>07,>81,>03,>8d,>00
     6BA0 8103 
     6BA2 8D00 
0599 6BA4 8109             byte  >81,>09,>86,>07,>82,>00
     6BA6 8607 
     6BA8 8200 
0600 6BAA 8107             byte  >81,>07,>81,>0f,>82,>00
     6BAC 810F 
     6BAE 8200 
0601 6BB0 8101             byte  >81,>01,>81,>07,>81,>08
     6BB2 8107 
     6BB4 8108 
0602 6BB6 8200             byte  >82,>00,>81,>01,>82,>07
     6BB8 8101 
     6BBA 8207 
0603 6BBC 8F00             byte  >8f,>00,>81,>0f,>84,>00
     6BBE 810F 
     6BC0 8400 
0604 6BC2 8109             byte  >81,>09,>81,>03,>82,>00
     6BC4 8103 
     6BC6 8200 
0605 6BC8 8207             byte  >82,>07,>81,>08,>82,>00
     6BCA 8108 
     6BCC 8200 
0606 6BCE 8108             byte  >81,>08,>82,>00,>81,>09
     6BD0 8200 
     6BD2 8109 
0607 6BD4 8D00             byte  >8d,>00,>81,>0f,>84,>00
     6BD6 810F 
     6BD8 8400 
0608 6BDA 810F             byte  >81,>0f,>81,>00,>81,>08
     6BDC 8100 
     6BDE 8108 
0609 6BE0 8200             byte  >82,>00,>81,>08,>81,>00
     6BE2 8108 
     6BE4 8100 
0610 6BE6 8108             byte  >81,>08,>83,>00,>81,>06
     6BE8 8300 
     6BEA 8106 
0611 6BEC 8200             byte  >82,>00,>81,>09,>8b,>00
     6BEE 8109 
     6BF0 8B00 
0612 6BF2 810E             byte  >81,>0e,>84,>07,>81,>0f
     6BF4 8407 
     6BF6 810F 
0613 6BF8 8200             byte  >82,>00,>81,>01,>82,>07
     6BFA 8101 
     6BFC 8207 
0614 6BFE 8102             byte  >81,>02,>81,>00,>81,>01
     6C00 8100 
     6C02 8101 
0615 6C04 8307             byte  >83,>07,>81,>04,>82,>00
     6C06 8104 
     6C08 8200 
0616 6C0A 810F             byte  >81,>0f,>9d,>00,>81,>09
     6C0C 9D00 
     6C0E 8109 
0617 6C10 810F             byte  >81,>0f,>87,>00,>8a,>07
     6C12 8700 
     6C14 8A07 
0618 6C16 9600             byte  >96,>00,>81,>09,>86,>07
     6C18 8109 
     6C1A 8607 
0619 6C1C 8300             byte  >83,>00,>81,>09,>84,>07
     6C1E 8109 
     6C20 8407 
0620 6C22 8300             byte  >83,>00,>84,>07,>83,>00
     6C24 8407 
     6C26 8300 
0621 6C28 8407             byte  >84,>07,>84,>00,>81,>08
     6C2A 8400 
     6C2C 8108 
0622 6C2E 8500             byte  >85,>00,>83,>07,>81,>0f
     6C30 8307 
     6C32 810F 
0623 6C34 8200             byte  >82,>00,>81,>07,>81,>00
     6C36 8107 
     6C38 8100 
0624 6C3A 8109             byte  >81,>09,>81,>00,>81,>0f
     6C3C 8100 
     6C3E 810F 
0625 6C40 8400             byte  >84,>00,>81,>09,>81,>00
     6C42 8109 
     6C44 8100 
0626 6C46 810F             byte  >81,>0f,>81,>00,>83,>07
     6C48 8100 
     6C4A 8307 
0627 6C4C 8109             byte  >81,>09,>83,>00,>81,>08
     6C4E 8300 
     6C50 8108 
0628 6C52 8400             byte  >84,>00,>81,>08,>82,>00
     6C54 8108 
     6C56 8200 
0629 6C58 8105             byte  >81,>05,>82,>00,>81,>0b
     6C5A 8200 
     6C5C 810B 
0630 6C5E 8107             byte  >81,>07,>81,>0a,>82,>05
     6C60 810A 
     6C62 8205 
0631 6C64 8300             byte  >83,>00,>81,>08,>82,>00
     6C66 8108 
     6C68 8200 
0632 6C6A 810F             byte  >81,>0f,>81,>00,>81,>0e
     6C6C 8100 
     6C6E 810E 
0633 6C70 8107             byte  >81,>07,>81,>0f,>82,>00
     6C72 810F 
     6C74 8200 
0634 6C76 810A             byte  >81,>0a,>82,>00,>81,>01
     6C78 8200 
     6C7A 8101 
0635 6C7C 8407             byte  >84,>07,>81,>02,>83,>00
     6C7E 8102 
     6C80 8300 
0636 6C82 8109             byte  >81,>09,>84,>07,>81,>0f
     6C84 8407 
     6C86 810F 
0637 6C88 8105             byte  >81,>05,>83,>07,>81,>04
     6C8A 8307 
     6C8C 8104 
0638 6C8E 8200             byte  >82,>00,>81,>09,>83,>07
     6C90 8109 
     6C92 8307 
0639 6C94 8200             byte  >82,>00,>81,>0f,>97,>00
     6C96 810F 
     6C98 9700 
0640 6C9A 8109             byte  >81,>09,>81,>0f,>85,>07
     6C9C 810F 
     6C9E 8507 
0641 6CA0 810F             byte  >81,>0f
0642               
0643               *-------------------------------------------------------------
0644               * RLE encoded character definitions for title "7th Pong"
0645               *-------------------------------------------------------------
0646               * Compressed 84 bytes / Uncompressed 120 bytes / 70% size
0647               rle_chars:
0648 6CA2 8708             byte >87,>08,>01,>0f                         ; 1
     6CA4 010F 
0649 6CA6 8708             byte >87,>08,>01,>f8                         ; 2
     6CA8 01F8 
0650 6CAA 8700             byte >87,>00,>01,>f8                         ; 3
     6CAC 01F8 
0651 6CAE 8708             byte >87,>08,>01,>ff                         ; 4
     6CB0 01FF 
0652 6CB2 8801             byte >88,>01                                 ; 5
0653 6CB4 8300             byte >83,>00,>05,>80,>40,>20,>10,>08         ; 6
     6CB6 0580 
     6CB8 4020 
     6CBA 1008 
0654 6CBC 8700             byte >87,>00,>01,>ff                         ; 7
     6CBE 01FF 
0655 6CC0 8808             byte >88,>08                                 ; 8
0656 6CC2 2080             byte >20,>80,>40,>20,>10,>08,>04,>02,>01     ; 9
     6CC4 4020 
     6CC6 1008 
     6CC8 0402 
     6CCA 0180 
0657 6CCC 4020             byte >80,>40,>20,>10,>10,>20,>40,>80         ; 10
     6CCE 1010 
     6CD0 2040 
     6CD2 8001 
0658 6CD4 0204             byte >01,>02,>04,>08,>08,>04,>02,>01         ; 11
     6CD6 0808 
     6CD8 0402 
     6CDA 013C 
0659 6CDC 4299             byte >3c,>42,>99,>a1,>a1,>99,>42,>3c         ; 12
     6CDE A1A1 
     6CE0 9942 
     6CE2 3C88 
0660 6CE4 0010             byte >88,>00                                 ; 13
0661 6CE6 0102             byte >10,>01,>02,>04,>08,>10,>20,>40,>ff     ; 14
     6CE8 0408 
     6CEA 1020 
     6CEC 40FF 
0662 6CEE 0102             byte >01,>02,>04,>08,>10,>20,>40,>80         ; 15
     6CF0 0408 
     6CF2 1020 
     6CF4 4080 
0663               
0664               
0665               *-------------------------------------------------------------
0666               * RLE encoded sprite patterns
0667               *-------------------------------------------------------------
0668               * Compressed 2 bytes / Uncompressed 10 bytes / 20% size
0669               rle_sprite_patterns:
0670 6CF6 8A18             byte  >8a,>18                   ; Paddle sprite + Ball sprite
0671               
0672               
0673               
0674               *-------------------------------------------------------------
0675               * Title screen messages
0676               *-------------------------------------------------------------
0677 6CF8 0348     high    byte 3
0678 6CF9 ....             text "HI-"
0679 6CFC 1034     sweet   byte 16
0680 6CFD ....             text "4K ATARIAGE 2018"
0681               play    byte 18
0682 6D0E ....             text "Press Fire To Play"
0683 6D20 120C     credit  byte 18
0684                       byte 12                         ; Copyright sign
0685 6D22 ....             text " Retroclouds Team"
0686               *-------------------------------------------------------------
0687               * Game screen messages
0688               *-------------------------------------------------------------
0689               msg_game_over:
0690                       byte  18
0691 6D34 ....             text  'G A M E  O V E R !'
0692               
0693               bonus25:
0694 6D46 0420             byte  4
0695 6D47 ....             text  ' +25'
0696               
0697               lost100:
0698                       byte  4
0699 6D4C ....             text  '-100'
0700               
0701               erase_hint:
0702 6D50 0400             byte  4
0703 6D52 0000             data  >0000,>0000
     6D54 0000 
0704               
0705               *-------------------------------------------------------------
0706               * Sprite table
0707               *-------------------------------------------------------------
0708 6D56 4F05     romsat  data  >4f05,>000f         ; Paddle 1
     6D58 000F 
0709 6D5A 4FF0             data  >4ff0,>000f         ; Paddle 2
     6D5C 000F 
0710 6D5E 3F70             data  >3f70,>010f         ; Ball
     6D60 010F 
0711 6D62 D000             data  >d000               ; EOF SAT
0712               
0713               
0714               * ##########################################################################
0715               * # Dump of LPC binary file "can_you_make_it.bin"
0716               * ##########################################################################
0717               can_you_make_it:
0718 6D64 6004             byte talkon
0719 6D66 18B5             byte >04,>18,>B5,>8D,>01,>DD,>B0,>14
     6D68 8D01 
     6D6A DDB0 
     6D6C 14BF 
0720 6D6E 6536             byte >BF,>65,>36,>8B,>A8,>3D,>9C,>5E
     6D70 8BA8 
     6D72 3D9C 
     6D74 5ECA 
0721 6D76 C475             byte >CA,>C4,>75,>C9,>30,>7B,>1E,>35
     6D78 C930 
     6D7A 7B1E 
     6D7C 35F5 
0722 6D7E 25C3             byte >F5,>25,>C3,>E8,>A5,>CD,>C5,>1A
     6D80 E8A5 
     6D82 CDC5 
     6D84 1A0F 
0723 6D86 7384             byte >0F,>73,>84,>14,>65,>5F,>DC,>9C
     6D88 1465 
     6D8A 5FDC 
     6D8C 9CAA 
0724 6D8E C852             byte >AA,>C8,>52,>2B,>4E,>F1,>8A,>61
     6D90 2B4E 
     6D92 F18A 
     6D94 6177 
0725 6D96 8E28             byte >77,>8E,>28,>C3,>9F,>CE,>45,>D5
     6D98 C39F 
     6D9A CE45 
     6D9C D56A 
0726 6D9E 0F7F             byte >6A,>0F,>7F,>F9,>20,>B6,>68,>3C
     6DA0 F920 
     6DA2 B668 
     6DA4 3C82 
0727 6DA6 5E8A             byte >82,>5E,>8A,>58,>AD,>CB,>08,>6B
     6DA8 58AD 
     6DAA CB08 
     6DAC 6B34 
0728 6DAE 0991             byte >34,>09,>91,>36,>23,>2E,>5E,>22
     6DB0 3623 
     6DB2 2E5E 
     6DB4 2294 
0729 6DB6 DBB4             byte >94,>DB,>B4,>AC,>06,>B6,>30,>49
     6DB8 AC06 
     6DBA B630 
     6DBC 4952 
0730 6DBE B216             byte >52,>B2,>16,>49,>D2,>35,>6E,>CB
     6DC0 49D2 
     6DC2 356E 
     6DC4 CB9B 
0731 6DC6 158A             byte >9B,>15,>8A,>50,>67,>23,>2B,>59
     6DC8 5067 
     6DCA 232B 
     6DCC 59DD 
0732 6DCE C8DA             byte >DD,>C8,>DA,>8C,>B4,>95,>34,>13
     6DD0 8CB4 
     6DD2 9534 
     6DD4 136B 
0733 6DD6 3392             byte >6B,>33,>92,>9E,>D3,>54,>A2,>CD
     6DD8 9ED3 
     6DDA 54A2 
     6DDC CD08 
0734 6DDE 7B74             byte >08,>7B,>74,>15,>EB,>36,>C3,>1F
     6DE0 15EB 
     6DE2 36C3 
     6DE4 1FC9 
0735 6DE6 94AC             byte >C9,>94,>AC,>9B,>34,>BF,>07,>26
     6DE8 9B34 
     6DEA BF07 
     6DEC 26E9 
0736 6DEE 6E12             byte >E9,>6E,>12,>BC,>9E,>59,>4D,>D5
     6DF0 BC9E 
     6DF2 594D 
     6DF4 D509 
0737 6DF6 0184             byte >09,>01,>84,>94,>66,>40,>37,>C4
     6DF8 9466 
     6DFA 4037 
     6DFC C4C5 
0738 6DFE 6A81             byte >C5,>6A,>81,>D8,>B3,>9B,>36,>B3
     6E00 D8B3 
     6E02 9B36 
     6E04 B358 
0739 6E06 D6CC             byte >58,>D6,>CC,>6E,>D2,>8C,>E2,>44
     6E08 6ED2 
     6E0A 8CE2 
     6E0C 4423 
0740 6E0E 2649             byte >23,>26,>49,>33,>8B,>17,>B1,>18
     6E10 338B 
     6E12 17B1 
     6E14 1827 
0741 6E16 CACD             byte >27,>CA,>CD,>8E,>2D,>7A,>E4,>02
     6E18 8E2D 
     6E1A 7AE4 
     6E1C 0202 
0742 6E1E 1609             byte >02,>16,>09,>53,>46,>33,>CA,>9E
     6E20 5346 
     6E22 33CA 
     6E24 9E95 
0743 6E26 C418             byte >95,>C4,>18,>5D,>07,>99,>E7,>12
     6E28 5D07 
     6E2A 99E7 
     6E2C 1261 
0744 6E2E 36E3             byte >61,>36,>E3,>6C,>56,>75,>11,>90
     6E30 6C56 
     6E32 7511 
     6E34 90A4 
0745 6E36 E903             byte >A4,>E9,>03,>BA,>0C,>7B,>40,>97
     6E38 BA0C 
     6E3A 7B40 
     6E3C 9700 
0746 6E3E 00FF             byte >00,>00
0747                       byte talkof
0748               
0749               * ##########################################################################
0750               * # Dump of LPC binary file "hahaha.bin"
0751               * ##########################################################################
0752 6E40 604E     hahaha  byte talkon
0753 6E42 2D9B             byte >4E,>2D,>9B,>2B,>2C,>EB,>14,>BE
     6E44 2B2C 
     6E46 EB14 
     6E48 BE6C 
0754 6E4A 1AAB             byte >6C,>1A,>AB,>4A,>32,>98,>72,>B4
     6E4C 4A32 
     6E4E 9872 
     6E50 B424 
0755 6E52 62CE             byte >24,>62,>CE,>60,>4B,>D6,>F2,>CA
     6E54 604B 
     6E56 D6F2 
     6E58 CAA8 
0756 6E5A 49CA             byte >A8,>49,>CA,>C5,>AD,>2A,>CC,>20
     6E5C C5AD 
     6E5E 2ACC 
     6E60 2020 
0757 6E62 26F1             byte >20,>26,>F1,>C1,>96,>6A,>2D,>13
     6E64 C196 
     6E66 6A2D 
     6E68 1371 
0758 6E6A 0653             byte >71,>06,>53,>A6,>15,>CF,>C4,>1E
     6E6C A615 
     6E6E CFC4 
     6E70 1E6C 
0759 6E72 29DE             byte >6C,>29,>DE,>5C,>93,>7A,>88,>A5
     6E74 5C93 
     6E76 7A88 
     6E78 A545 
0760 6E7A 5357             byte >45,>53,>57,>D4,>A2,>A7,>2E,>65
     6E7C D4A2 
     6E7E A72E 
     6E80 651B 
0761 6E82 7287             byte >1B,>72,>87,>98,>B7,>A5,>74,>45
     6E84 98B7 
     6E86 A574 
     6E88 451B 
0762 6E8A 5C89             byte >1B,>5C,>89,>36,>DC,>93,>64,>08
     6E8C 36DC 
     6E8E 9364 
     6E90 08A5 
0763 6E92 784B             byte >A5,>78,>4B,>56,>BD,>A1,>A7,>61
     6E94 56BD 
     6E96 A1A7 
     6E98 61E9 
0764 6E9A 5D61             byte >E9,>5D,>61,>9D,>93,>BA,>7B,>46
     6E9C 9D93 
     6E9E BA7B 
     6EA0 4649 
0765 6EA2 1D7A             byte >49,>1D,>7A,>EA,>5A,>DE,>15,>75
     6EA4 EA5A 
     6EA6 DE15 
     6EA8 7548 
0766 6EAA A5FA             byte >48,>A5,>FA,>50,>55,>DC,>C1,>D7
     6EAC 5055 
     6EAE DCC1 
     6EB0 D764 
0767 6EB2 4B31             byte >64,>4B,>31,>69,>87,>50,>B3,>8D
     6EB4 6987 
     6EB6 50B3 
     6EB8 8D44 
0768 6EBA D61B             byte >44,>D6,>1B,>72,>AD,>BE,>38,>99
     6EBC 72AD 
     6EBE BE38 
     6EC0 9964 
0769 6EC2 C8A5             byte >64,>C8,>A5,>C7,>50,>65,>93,>A1
     6EC4 C750 
     6EC6 6593 
     6EC8 A194 
0770 6ECA E28B             byte >94,>E2,>8B,>E3,>49,>86,>5E,>AA
     6ECC E349 
     6ECE 865E 
     6ED0 AA0D 
0771 6ED2 4EC6             byte >0D,>4E,>C6,>19,>66,>A9,>36,>78
     6ED4 1966 
     6ED6 A936 
     6ED8 7899 
0772 6EDA A4D9             byte >99,>A4,>D9,>25,>EB,>D0,>65,>93
     6EDC 25EB 
     6EDE D065 
     6EE0 93E4 
0773 6EE2 9662             byte >E4,>96,>62,>8D,>1F,>A9,>BC,>A7
     6EE4 8D1F 
     6EE6 A9BC 
     6EE8 A77D 
0774 6EEA 1C3E             byte >7D,>1C,>3E,>A0,>CB,>30
     6EEC A0CB 
     6EEE 30FF 
0775                       byte talkof
0776               
0777               * ##########################################################################
0778               * # Title screen music "ballblazer" sample by OLD CS1
0779               * ##########################################################################
0780               title_screen_music:
0781 6EF0 05C7             byte >05,>C7,>08,>DF,>E3,>F0,>09                      * G#33, P3
     6EF2 08DF 
     6EF4 E3F0 
     6EF6 0901 
0782 6EF8 F803             byte >01,>F8,>03
0783 6EFA 03CA             byte >03,>CA,>05,>F0,>09                              * D#43
     6EFC 05F0 
     6EFE 0901 
0784 6F00 F803             byte >01,>F8,>03
0785 6F02 0A8B             byte >0A,>8B,>23,>93,>AC,>1A,>B3,>CC,>04,>E5,>F3,>03  * G11, C22, F#43, W1
     6F04 2393 
     6F06 AC1A 
     6F08 B3CC 
     6F0A 04E5 
     6F0C F303 
0786 6F0E 02E3             byte >02,>E3,>F0,>06                                  * P3
     6F10 F006 
0787 6F12 039F             byte >03,>9F,>BF,>F8,>03
     6F14 BFF8 
     6F16 0303 
0788 6F18 C708             byte >03,>C7,>08,>F0,>09                              * G#33
     6F1A F009 
0789 6F1C 01FF             byte >01,>FF,>12
     6F1E 1203 
0790 6F20 CA05             byte >03,>CA,>05,>F0,>09                              * D#43
     6F22 F009 
0791 6F24 01F8             byte >01,>F8,>03
     6F26 0304 
0792 6F28 C505             byte >04,>C5,>05,>E5,>F3,>03                          * E43, W1
     6F2A E5F3 
     6F2C 0302 
0793 6F2E E3F0             byte >02,>E3,>F0,>06                                  * P3
     6F30 0601 
0794 6F32 F803             byte >01,>F8,>03
0795 6F34 03C9             byte >03,>C9,>03,>F0,>09                              * B43
     6F36 03F0 
     6F38 0901 
0796 6F3A F803             byte >01,>F8,>03
0797 6F3C 03C7             byte >03,>C7,>08,>F0,>09                              * G#33
     6F3E 08F0 
     6F40 0901 
0798 6F42 F803             byte >01,>F8,>03
0799 6F44 03CA             byte >03,>CA,>05,>F0,>09                              * D#43
     6F46 05F0 
     6F48 0901 
0800 6F4A F803             byte >01,>F8,>03
0801 6F4C 0693             byte >06,>93,>B3,>CC,>04,>E5,>F3,>03                  * F#43, W1
     6F4E B3CC 
     6F50 04E5 
     6F52 F303 
0802 6F54 02E3             byte >02,>E3,>F0,>06                                  * P3
     6F56 F006 
0803 6F58 039F             byte >03,>9F,>BF,>F8,>03
     6F5A BFF8 
     6F5C 0303 
0804 6F5E C708             byte >03,>C7,>08,>F0,>09                              * G#33
     6F60 F009 
0805 6F62 01FF             byte >01,>FF,>12
     6F64 1203 
0806 6F66 CA05             byte >03,>CA,>05,>F0,>09                              * D#43
     6F68 F009 
0807 6F6A 01F8             byte >01,>F8,>03
     6F6C 0304 
0808 6F6E C506             byte >04,>C5,>06,>E5,>F3,>03                          * C#43, W1
     6F70 E5F3 
     6F72 0302 
0809 6F74 E3F0             byte >02,>E3,>F0,>06                                  * P3
     6F76 0601 
0810 6F78 F803             byte >01,>F8,>03
0811 6F7A 03C1             byte >03,>C1,>07,>F0,>09                              * B33
     6F7C 07F0 
     6F7E 0901 
0812 6F80 F803             byte >01,>F8,>03
0813 6F82 03C7             byte >03,>C7,>08,>F0,>09                              * G#33
     6F84 08F0 
     6F86 0901 
0814 6F88 F803             byte >01,>F8,>03
0815 6F8A 03CA             byte >03,>CA,>05,>F0,>09                              * D#43
     6F8C 05F0 
     6F8E 0901 
0816 6F90 F803             byte >01,>F8,>03
0817 6F92 0693             byte >06,>93,>B3,>CC,>04,>E5,>F3,>03                  * F#43, W1
     6F94 B3CC 
     6F96 04E5 
     6F98 F303 
0818 6F9A 02E3             byte >02,>E3,>F0,>06                                  * P3
     6F9C F006 
0819 6F9E 039F             byte >03,>9F,>BF,>F8,>03
     6FA0 BFF8 
     6FA2 0303 
0820 6FA4 C708             byte >03,>C7,>08,>F0,>09                              * G#33
     6FA6 F009 
0821 6FA8 01FF             byte >01,>FF,>12
     6FAA 1203 
0822 6FAC CA05             byte >03,>CA,>05,>F0,>09                              * D#43
     6FAE F009 
0823 6FB0 01F8             byte >01,>F8,>03
     6FB2 0304 
0824 6FB4 C505             byte >04,>C5,>05,>E5,>F3,>03                          * E43, W1
     6FB6 E5F3 
     6FB8 0302 
0825 6FBA E3F0             byte >02,>E3,>F0,>06                                  * P3
     6FBC 0601 
0826 6FBE F803             byte >01,>F8,>03
0827 6FC0 03C9             byte >03,>C9,>03,>F0,>09                              * B43
     6FC2 03F0 
     6FC4 0901 
0828 6FC6 F803             byte >01,>F8,>03
0829 6FC8 0A8C             byte >0A,>8C,>1F,>93,>AE,>12,>B3,>C5,>06,>E3,>F0,>12  * A11, F#22, C#43, P3
     6FCA 1F93 
     6FCC AE12 
     6FCE B3C5 
     6FD0 06E3 
     6FD2 F012 
0830 6FD4 039F             byte >03,>9F,>BF,>FF,>06
     6FD6 BFFF 
     6FD8 060A 
0831 6FDA 8B23             byte >0A,>8B,>23,>93,>A3,>15,>B3,>C1,>07,>E5,>F3,>03  * G11, E22, B33, W1
     6FDC 93A3 
     6FDE 15B3 
     6FE0 C107 
     6FE2 E5F3 
     6FE4 0302 
0832 6FE6 E3F0             byte >02,>E3,>F0,>0F                                  * P3
     6FE8 0F03 
0833 6FEA 9FBF             byte >03,>9F,>BF,>FF,>06
     6FEC FF06 
0834 6FEE 098C             byte >09,>8C,>1F,>93,>A0,>14,>B3,>CA,>0A,>F0,>04      * A11, F22, E33
     6FF0 1F93 
     6FF2 A014 
     6FF4 B3CA 
     6FF6 0AF0 
     6FF8 0403 
0835 6FFA 9FBF             byte >03,>9F,>BF,>F8,>02
     6FFC F802 
0836 6FFE 078B             byte >07,>8B,>23,>93,>A8,>16,>B3,>F0,>04              * G11, D#22
     7000 2393 
     7002 A816 
     7004 B3F0 
     7006 0403 
0837 7008 9FBF             byte >03,>9F,>BF,>FF,>0E
     700A FF0E 
0838 700C 088C             byte >08,>8C,>1F,>93,>AC,>1A,>B3,>E5,>F3,>03          * A11, C22, W1
     700E 1F93 
     7010 AC1A 
     7012 B3E5 
     7014 F303 
0839 7016 02E3             byte >02,>E3,>F0,>0C                                  * P3
     7018 F00C 
0840 701A 0000             byte >00
